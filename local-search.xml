<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>高并发</title>
    <link href="/2020/08/12/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/08/12/%E9%AB%98%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p><img src="/12/%E9%AB%98%E5%B9%B6%E5%8F%91/image-20200514095332547.png" srcset="/img/loading.gif" alt="image-20200514095332547"></p><p><img src="/12/%E9%AB%98%E5%B9%B6%E5%8F%91/image-20200514103951205.png" srcset="/img/loading.gif" alt="image-20200514103951205"></p><p><img src="/12/%E9%AB%98%E5%B9%B6%E5%8F%91/image-20200514141449980.png" srcset="/img/loading.gif" alt="image-20200514141449980"></p><p><img src="/12/%E9%AB%98%E5%B9%B6%E5%8F%91/image-20200514142338542.png" srcset="/img/loading.gif" alt="image-20200514142338542"></p><p><img src="/12/%E9%AB%98%E5%B9%B6%E5%8F%91/image-20200515104453047.png" srcset="/img/loading.gif" alt="image-20200515104453047"></p><p><img src="/12/%E9%AB%98%E5%B9%B6%E5%8F%91/image-20200518150757166.png" srcset="/img/loading.gif" alt="image-20200518150757166"></p><p>系统拆分</p><p>将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。</p><p>缓存</p><p>缓存，必须得用缓存。大部分的高并发场景，都是<strong>读多写少</strong>，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的<strong>读场景，怎么用缓存来抗高并发</strong>。</p><p>MQ</p><p>MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，<strong>后边系统消费后慢慢写</strong>，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。</p><p>分库分表</p><p>分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表<strong>拆分为多个表</strong>，每个表的数据量保持少一点，提高 sql 跑的性能。</p><p>读写分离</p><p>读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，<strong>主库写</strong>入，<strong>从库读</strong>取，搞一个读写分离。<strong>读流量太多</strong>的时候，还可以<strong>加更多的从库</strong>。</p><p>ElasticSearch</p><p>Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。</p><p>上面的 6 点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。</p><p>说句实话，毕竟你真正厉害的一点，不是在于弄明白一些技术，或者大概知道一个高并发系统应该长什么样？其实实际上在真正的复杂的业务系统里，做高并发要远远比上面提到的点要复杂几十倍到上百倍。你需要考虑：哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何 join，哪些数据要放到缓存里去，放哪些数据再可以扛住高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造，这个过程是无比复杂的，一旦做过一次，并且做好了，你在这个市场上就会非常的吃香。</p><p>其实大部分公司，真正看重的，不是说你掌握高并发相关的一些基本的架构知识，架构中的一些技术，RocketMQ、Kafka、Redis、Elasticsearch，高并发这一块，你了解了，也只能是次一等的人才。对一个有几十万行代码的复杂的分布式系统，一步一步架构、设计以及实践过高并发架构的人，这个经验是难能可贵的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>连接池</title>
    <link href="/2020/08/12/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/2020/08/12/%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="公式"><a href="#公式" class="headerlink" title=". 公式"></a>. 公式</h4><blockquote><p>下面的公式由 PostgreSQL 项目提供，作为起点，但我们相信它将在很大程度上适用于数据库。您应该测试您的应用程序，即模拟预期的负载，并在此起点周围尝试不同的池设置：</p><blockquote><pre><code class="hljs ini"><span class="hljs-attr">connections</span> = ((core_count * <span class="hljs-number">2</span>) + effective_spindle_count)</code></pre><p>多年来在很多基准测试中表现良好的公式是为了获得最佳吞吐量，活动连接的数量应该在某处接近 <code>((core_count * 2) + effective_spindle_count)</code>。 核心数不应包括超线程，即使启用了超线程也是如此。 如果有效的主核数为零活动数据集已完全缓存，并接近实际的主轴数随着缓存命中率下降。 ……到目前为止还没有任何分析配方与 SSD 的配合效果如何。</p></blockquote><p>猜猜那意味着什么？你的带有一个硬盘的小型 4 核 i7 服务器应运行以下连接池： 9 = ((4 * 2) + 1)。称之为 10 一个很好的圆数。看起来很低？尝试一下，我们打赌您可以轻松处理 3000 个前端用户在这样的设置下以 6000 TPS 运行简单查询。如果您运行负载测试，您可能会看到 TPS 速率开始下降，并且前端响应时间开始攀升，因为您将连接池推迟 10（在给定硬件上）。</p><p>PostgreSQL给我们提供了一个公式：</p><p><strong>连接数 = ((核心数 * 2) + 有效磁盘数)</strong></p></blockquote><p>好了，按照这个公式，如果说你的服务器 CPU 是 4核 i7 的，连接池大小应该为 <code>((4*2)+1)=9</code>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2020/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/08/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>单例模式的写法大的方面可以分为5种五种:</p><h5 id="①懒汉式"><a href="#①懒汉式" class="headerlink" title="①懒汉式"></a>①懒汉式</h5><pre><code class="hljs java">存在线程安全问题    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-keyword">null</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;instance=<span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> instance;&#125;&#125;</code></pre><p>这种方式是在调用getInstance方法的时候才创建对象的，所以它比较懒因此被称为懒汉式。<br>在上述两种写法中懒汉式其实是存在线程安全问题的，喜欢刨根问题的同学可能会问，存在怎样的线程安全问题？怎样导致这种问题的？好，我们来说一下什么情况下这种写法会有问题。在运行过程中可能存在这么一种情况：有多个线程去调用getInstance方法来获取Singleton的实例，那么就有可能发生这样一种情况当第一个线程在执行if(instance==null)这个语句时，此时instance是为null的进入语句。在还没有执行instance=new Singleton()时(此时instance是为null的)第二个线程也进入if(instance==null)这个语句，因为之前进入这个语句的线程中还没有执行instance=new Singleton()，所以它会执行instance=new Singleton()来实例化Singleton对象，因为第二个线程也进入了if语句所以它也会实例化Singleton对象。这样就导致了实例化了两个Singleton对象。所以单例模式的懒汉式是存在线程安全问题的，既然它存在问题，那么可能有解决这个问题的方法，那么究竟怎么解决呢？对这种问题可能很多人会想到加锁于是出现了下面这种写法。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-keyword">null</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>(instance==<span class="hljs-keyword">null</span>)&#123;instance=<span class="hljs-keyword">new</span> Singleton();&#125;<span class="hljs-keyword">return</span> instance;&#125;</code></pre><p>缺点：效率太低了，每个线程在想获得类的实例时候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低要改进。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 懒汉式变种，属于懒汉式中最好的写法，保证了：延迟加载和线程安全</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-keyword">null</span>;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                instance = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;  &#125;</code></pre><h5 id="②饿汉式"><a href="#②饿汉式" class="headerlink" title="②饿汉式"></a>②饿汉式</h5><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123; <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance=<span class="hljs-keyword">new</span> Singleton();<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> instance;&#125;&#125;访问方式：    Singleton instance = Singleton.getInstance();</code></pre><p>优点：从它的实现中我们可以看到，这种方式的实现比较简单，在类加载的时候就完成了实例化，避免了线程的同步问题。</p><p>缺点：由于在类加载的时候就实例化了，所以没有达到Lazy Loading(懒加载)的效果，也就是说可能我没有用到这个实例，但是它</p><p>也会加载，会造成内存的浪费(但是这个浪费可以忽略，所以这种方式也是推荐使用的)。</p><h5 id="③双重校验锁"><a href="#③双重校验锁" class="headerlink" title="③双重校验锁"></a>③双重校验锁</h5><h5 id="④静态内部类"><a href="#④静态内部类" class="headerlink" title="④静态内部类"></a>④静态内部类</h5><h5 id="⑤枚举"><a href="#⑤枚举" class="headerlink" title="⑤枚举"></a>⑤枚举</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>秒杀</title>
    <link href="/2020/08/12/%E7%A7%92%E6%9D%80/"/>
    <url>/2020/08/12/%E7%A7%92%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<h1 id="秒杀"><a href="#秒杀" class="headerlink" title="秒杀"></a>秒杀</h1><h4 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h4><ul><li>高并发</li><li>超卖</li><li>恶意请求</li><li>链接暴露</li><li>数据库</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>并发编程</title>
    <link href="/2020/08/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2020/08/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><h4 id="4-8-wait-notify-的正确姿势"><a href="#4-8-wait-notify-的正确姿势" class="headerlink" title="4.8 wait notify 的正确姿势"></a>4.8 wait notify 的正确姿势</h4><p>开始之前先看看 sleep(long n) 和 wait(long n) 的区别 </p><p>1) sleep 是 Thread 方法，而 wait 是 Object 的方法 </p><p>2) sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用 </p><p>3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 </p><p>4) 它们 状态TIMED_WAITING</p><p><strong>3.3</strong> <strong>查看进程线程的方法</strong></p><p><strong>windows</strong></p><p>任务管理器可以查看进程和线程数，也可以用来杀死进程</p><p>tasklist 查看进程</p><p>taskkill 杀死进程</p><p><strong>linux</strong></p><p>ps -fe 查看所有进程</p><p>ps -fT -p <PID> 查看某个进程（PID）的所有线程</PID></p><p>kill 杀死进程</p><p>top 按大写 H 切换是否显示线程</p><p>top -H -p <PID> 查看某个进程（PID）的所有线程</PID></p><p><strong>Java</strong></p><p>jps 命令查看所有 Java 进程</p><p>jstack <PID> 查看某个 Java 进程（PID）的所有线程状态</PID></p><p>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p><p>jconsole 远程监控配置</p><p>需要以如下方式运行你的 java 类</p><p>修改 /etc/hosts 文件将 127.0.0.1 映射至主机名</p><p>如果要认证访问，还需要做如下步骤</p><p>复制 jmxremote.password 文件</p><p>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</p><p>连接时填入 controlRole（用户名），R&amp;D（密码）</p><p><strong>3.4</strong> <strong>*** **原理之线程运行</strong></p><p>java -Djava.rmi.server.hostname=<code>ip地址</code> -Dcom.sun.management.jmxremote -</p><p>Dcom.sun.management.jmxremote.port=<code>连接端口</code> -Dcom.sun.management.jmxremote.ssl=是否安全连接 -</p><p>Dcom.sun.management.jmxremote.authenticate=是否认证 java类北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090</p><p><strong>栈与栈帧</strong></p><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><p>我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟</p><p>机就会为其分配一块栈内存。</p><p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</p><p>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</p><p><strong>线程上下文切换（**</strong>Thread Context Switch<strong>**）</strong></p><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><p>线程的 cpu 时间片用完</p><p>垃圾回收</p><p>有更高优先级的线程需要运行</p><p>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</p><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念</p><p>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><p>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</p><p>Context Switch 频繁发生会影响性能</p><p><strong>4.13 ReentrantLock</strong></p><p>相对于 synchronized 它具备如下特点</p><p>可中断</p><p>可以设置超时时间</p><p>可以设置为公平锁</p><p>支持多个条件变量</p><p>与 synchronized 一样，都支持可重入</p><p>基本语法</p><p><strong>可重入</strong></p><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</p><p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><p>// 获取锁</p><p>reentrantLock.lock();</p><p>try {</p><p> // 临界区</p><p>} finally {</p><p> // 释放锁</p><p> reentrantLock.unlock();</p><p>}</p><h4 id="cas特点"><a href="#cas特点" class="headerlink" title="cas特点"></a>cas特点</h4><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/C:%5CUsers%5Cpoon%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200525144011194.png" srcset="/img/loading.gif" alt="image-20200525144011194"></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200622151159585.png" srcset="/img/loading.gif" alt="image-20200622151159585"></p><h3 id="线程池执行流程，即对应execute-方法："><a href="#线程池执行流程，即对应execute-方法：" class="headerlink" title="线程池执行流程，即对应execute()方法："></a>线程池执行流程，即对应execute()方法：</h3><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/16bca03a5a6fd78f" srcset="/img/loading.gif" alt="img"></p><ul><li>提交一个任务，线程池里存活的核心线程数小于线程数corePoolSize时，线程池会创建一个核心线程去处理提交的任务。</li><li>如果线程池核心线程数已满，即线程数已经等于corePoolSize，一个新提交的任务，会被放进任务队列workQueue排队等待执行。</li><li>当线程池里面存活的线程数已经等于corePoolSize了,并且任务队列workQueue也满，判断线程数是否达到maximumPoolSize，即最大线程数是否已满，如果没到达，创建一个非核心线程执行提交的任务。</li><li>如果当前的线程数达到了maximumPoolSize，还有新的任务过来的话，直接采用拒绝策略处理。</li></ul><h2 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h2><p><strong>线程池都有哪几种工作队列？</strong></p><ul><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>DelayQueue</li><li>PriorityBlockingQueue</li><li>SynchronousQueue</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列；</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</p><p>针对面试题：<strong>线程池都有哪几种工作队列？</strong> 我觉得，<strong>回答以上几种ArrayBlockingQueue，LinkedBlockingQueue，SynchronousQueue等，说出它们的特点，并结合使用到对应队列的常用线程池(如newFixedThreadPool线程池使用LinkedBlockingQueue)，进行展开阐述，</strong> 就可以啦。</p><h3 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h3><ul><li>AbortPolicy(抛出一个异常，默认的)</li><li>DiscardPolicy(直接丢弃任务)</li><li>DiscardOldestPolicy（丢弃队列里最老的任务，将当前这个任务继续提交给线程池）</li><li>CallerRunsPolicy（交给线程池调用所在的线程进行处理)</li></ul><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200526162503080-1592822446076.png" srcset="/img/loading.gif" alt="image-20200526162503080"></p><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200526162924824.png" srcset="/img/loading.gif" alt="image-20200526162924824"></p><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200526163407278.png" srcset="/img/loading.gif" alt="image-20200526163407278"></p><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/C:%5CUsers%5Cpoon%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200526163621050.png" srcset="/img/loading.gif" alt="image-20200526163621050"></p><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200526163711851.png" srcset="/img/loading.gif" alt="image-20200526163711851"></p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200526164907304.png" srcset="/img/loading.gif" alt="image-20200526164907304" style="zoom: 80%;"><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200526171708447.png" srcset="/img/loading.gif" alt="image-20200526171708447"></p><p><img src="/12/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20200526171901236.png" srcset="/img/loading.gif" alt="image-20200526171901236"></p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>商城</title>
    <link href="/2020/08/12/%E5%95%86%E5%9F%8E/"/>
    <url>/2020/08/12/%E5%95%86%E5%9F%8E/</url>
    
    <content type="html"><![CDATA[<h3 id="限时订单"><a href="#限时订单" class="headerlink" title="限时订单"></a>限时订单</h3><p><img src="/12/%E5%95%86%E5%9F%8E/image-20200515162126843.png" srcset="/img/loading.gif" alt="image-20200515162126843"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分库分表</title>
    <link href="/2020/08/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <url>/2020/08/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/F:%5Cw%5CMD%5Cimage%5Cimage-20200605113148957.png" srcset="/img/loading.gif" alt="image-20200605113148957"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605113235263.png" srcset="/img/loading.gif" alt="image-20200605113235263"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605135924729.png" srcset="/img/loading.gif" alt="image-20200605135924729"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605140056036.png" srcset="/img/loading.gif" alt="image-20200605140056036"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605140229915.png" srcset="/img/loading.gif" alt="image-20200605140229915"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605141005988.png" srcset="/img/loading.gif" alt="image-20200605141005988"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605140811419.png" srcset="/img/loading.gif" alt="image-20200605140811419"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605140925648.png" srcset="/img/loading.gif" alt="image-20200605140925648"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605141501941.png" srcset="/img/loading.gif" alt="image-20200605141501941"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605141515121.png" srcset="/img/loading.gif" alt="image-20200605141515121"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605141802567.png" srcset="/img/loading.gif" alt="image-20200605141802567"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605142038581.png" srcset="/img/loading.gif" alt="image-20200605142038581"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605142104733.png" srcset="/img/loading.gif" alt="image-20200605142104733"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605142139807.png" srcset="/img/loading.gif" alt="image-20200605142139807"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/F:%5Cw%5CMD%5Cimage%5Cimage-20200605142153992.png" srcset="/img/loading.gif" alt="image-20200605142153992"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605142212793.png" srcset="/img/loading.gif" alt="image-20200605142212793"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605142313133.png" srcset="/img/loading.gif" alt="image-20200605142313133"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605142637273.png" srcset="/img/loading.gif" alt="image-20200605142637273"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605143108888.png" srcset="/img/loading.gif" alt="image-20200605143108888"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605143155632.png" srcset="/img/loading.gif" alt="image-20200605143155632"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605143420317.png" srcset="/img/loading.gif" alt="image-20200605143420317"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605163955630.png" srcset="/img/loading.gif" alt="image-20200605163955630"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605172322264.png" srcset="/img/loading.gif" alt="image-20200605172322264"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605173435082.png" srcset="/img/loading.gif" alt="image-20200605173435082"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605173506177.png" srcset="/img/loading.gif" alt="image-20200605173506177"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605173622594.png" srcset="/img/loading.gif" alt="image-20200605173622594"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605174030850.png" srcset="/img/loading.gif" alt="image-20200605174030850"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605174221827.png" srcset="/img/loading.gif" alt="image-20200605174221827"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200605175601894.png" srcset="/img/loading.gif" alt="image-20200605175601894"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200608103531891.png" srcset="/img/loading.gif" alt="image-20200608103531891"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200608103541178.png" srcset="/img/loading.gif" alt="image-20200608103541178"></p><p><img src="/12/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/image-20200608103730912.png" srcset="/img/loading.gif" alt="image-20200608103730912"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务</title>
    <link href="/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p><img src="/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200610135451688.png" srcset="/img/loading.gif" alt="image-20200610135451688"></p><p><img src="/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200610144016957.png" srcset="/img/loading.gif" alt="image-20200610144016957"></p><p><img src="/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200611135332514.png" srcset="/img/loading.gif" alt="image-20200611135332514"></p><p><img src="/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200611135341448.png" srcset="/img/loading.gif" alt="image-20200611135341448"></p><p><img src="/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200611141022867.png" srcset="/img/loading.gif" alt="image-20200611141022867"></p><p><img src="/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200611155223282.png" srcset="/img/loading.gif" alt="image-20200611155223282"></p><p><img src="/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200611161503026.png" srcset="/img/loading.gif" alt="image-20200611161503026"></p><p><img src="/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200611162921917.png" srcset="/img/loading.gif" alt="image-20200611162921917"></p><p><img src="/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/image-20200611165805912.png" srcset="/img/loading.gif" alt="image-20200611165805912"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式ID</title>
    <link href="/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8FID/"/>
    <url>/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    
    <content type="html"><![CDATA[<h2 id="一、为什么要用分布式ID？"><a href="#一、为什么要用分布式ID？" class="headerlink" title="一、为什么要用分布式ID？"></a>一、为什么要用分布式ID？</h2><p>在说分布式ID的具体实现之前，我们来简单分析一下为什么用分布式ID？分布式ID应该满足哪些特征？</p><p><strong>1、什么是分布式ID？</strong></p><p>拿MySQL数据库举个栗子：</p><p>在我们业务数据量不大的时候，单库单表完全可以支撑现有业务，数据再大一点搞个MySQL主从同步读写分离也能对付。</p><p>但随着数据日渐增长，主从同步也扛不住了，就需要对数据库进行分库分表，但分库分表后需要有一个唯一ID来标识一条数据，数据库的自增ID显然不能满足需求；特别一点的如订单、优惠券也都需要有<code>唯一ID</code>做标识。此时一个能够生成<code>全局唯一ID</code>的系统是非常必要的。那么这个<code>全局唯一ID</code>就叫<code>分布式ID</code>。</p><p><strong>2、那么分布式ID需要满足那些条件？</strong></p><ul><li>全局唯一：必须保证ID是全局性唯一的，基本要求</li><li>高性能：高可用低延时，ID生成响应要块，否则反倒会成为业务瓶颈</li><li>高可用：100%的可用性是骗人的，但是也要无限接近于100%的可用性</li><li>好接入：要秉着拿来即用的设计原则，在系统设计和实现上要尽可能的简单</li><li>趋势递增：最好趋势递增，这个要求就得看具体业务场景了，一般不严格要求</li></ul><h2 id="二、-分布式ID都有哪些生成方式？"><a href="#二、-分布式ID都有哪些生成方式？" class="headerlink" title="二、 分布式ID都有哪些生成方式？"></a>二、 分布式ID都有哪些生成方式？</h2><p>今天主要分析一下以下9种，分布式ID生成器方式以及优缺点：</p><ul><li>UUID</li><li>数据库自增ID</li><li>数据库多主模式</li><li>号段模式</li><li>Redis</li><li>雪花算法（SnowFlake）</li><li>滴滴出品（TinyID）</li><li>百度 （Uidgenerator）</li><li>美团（Leaf）</li></ul><p>那么它们都是如何实现？以及各自有什么优缺点？我们往下看</p><p><strong>1、基于UUID</strong></p><p>在Java的世界里，想要得到一个具有唯一性的ID，首先被想到可能就是<code>UUID</code>，毕竟它有着全球唯一的特性。那么<code>UUID</code>可以做<code>分布式ID</code>吗？<strong>答案是可以的，但是并不推荐！</strong></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String uuid = UUID.randomUUID().toString().replaceAll(<span class="hljs-string">"-"</span>,<span class="hljs-string">""</span>);       System.out.println(uuid); &#125;</code></pre><p><code>UUID</code>的生成简单到只有一行代码，输出结果 <code>c2b8c2b9e46c47e3b30dca3b0d447718</code>，但UUID却并不适用于实际的业务需求。像用作订单号<code>UUID</code>这样的字符串没有丝毫的意义，看不出和订单相关的有用信息；而对于数据库来说用作业务<code>主键ID</code>，它不仅是太长还是字符串，存储性能差查询也很耗时，所以不推荐用作<code>分布式ID</code>。</p><p><strong>优点：</strong></p><ul><li>生成足够简单，本地生成无网络消耗，具有唯一性</li></ul><p><strong>缺点：</strong></p><ul><li>无序的字符串，不具备趋势自增特性</li><li>没有具体的业务含义</li><li>长度过长16 字节128位，36位长度的字符串，存储以及查询对MySQL的性能消耗较大，MySQL官方明确建议主键要尽量越短越好，作为数据库主键 <code>UUID</code> 的无序性会导致数据位置频繁变动，严重影响性能。</li></ul><p><strong>2、基于数据库自增ID</strong></p><p>基于数据库的<code>auto_increment</code>自增ID完全可以充当<code>分布式ID</code>，具体实现：需要一个单独的MySQL实例用来生成ID，建表结构如下：</p><pre><code class="hljs java">CREATE DATABASE `SEQ_ID`;CREATE TABLE SEQID.SEQUENCE_ID (    <span class="hljs-function">id <span class="hljs-title">bigint</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span> unsigned NOT NULL auto_increment, </span><span class="hljs-function">    value <span class="hljs-title">char</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span> NOT NULL <span class="hljs-keyword">default</span> '',</span><span class="hljs-function">    PRIMARY <span class="hljs-title">KEY</span> <span class="hljs-params">(id)</span>,</span><span class="hljs-function">) ENGINE</span>=MyISAM;</code></pre><pre><code class="hljs java"><span class="hljs-function">insert into <span class="hljs-title">SEQUENCE_ID</span><span class="hljs-params">(value)</span>  <span class="hljs-title">VALUES</span> <span class="hljs-params">(<span class="hljs-string">'values'</span>)</span></span>;</code></pre><p>当我们需要一个ID的时候，向表中插入一条记录返回<code>主键ID</code>，但这种方式有一个比较致命的缺点，访问量激增时MySQL本身就是系统的瓶颈，用它来实现分布式服务风险比较大，不推荐！</p><p><strong>优点：</strong></p><ul><li>实现简单，ID单调自增，数值类型查询速度快</li></ul><p><strong>缺点：</strong></p><ul><li>DB单点存在宕机风险，无法扛住高并发场景</li></ul><p><strong>3、基于数据库集群模式</strong></p><p>前边说了单点数据库方式不可取，那对上边的方式做一些高可用优化，换成主从模式集群。害怕一个主节点挂掉没法用，那就做双主模式集群，也就是两个Mysql实例都能单独的生产自增ID。</p><p>那这样还会有个问题，两个MySQL实例的自增ID都从1开始，<strong>会生成重复的ID怎么办？</strong></p><p><strong>解决方案</strong>：设置<code>起始值</code>和<code>自增步长</code></p><p>MySQL_1 配置：</p><pre><code class="hljs java">set @<span class="hljs-meta">@auto</span>_increment_offset = <span class="hljs-number">1</span>;     -- 起始值set @<span class="hljs-meta">@auto</span>_increment_increment = <span class="hljs-number">2</span>;  -- 步长</code></pre><p>MySQL_2 配置：</p><pre><code class="hljs java">set @<span class="hljs-meta">@auto</span>_increment_offset = <span class="hljs-number">2</span>;     -- 起始值set @<span class="hljs-meta">@auto</span>_increment_increment = <span class="hljs-number">2</span>;  -- 步长</code></pre><p>这样两个MySQL实例的自增ID分别就是：</p><blockquote><p>1、3、5、7、9 2、4、6、8、10</p></blockquote><p>那如果集群后的性能还是扛不住高并发咋办？就要进行MySQL扩容增加节点，这是一个比较麻烦的事。</p><p><img src="https://pic3.zhimg.com/80/v2-a7f8c5f285c3269becc8351cdc703b2a_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p>从上图可以看出，水平扩展的数据库集群，有利于解决数据库单点压力的问题，同时为了ID生成特性，将自增步长按照机器数量来设置。</p><p>增加第三台<code>MySQL</code>实例需要人工修改一、二两台<code>MySQL实例</code>的起始值和步长，把<code>第三台机器的ID</code>起始生成位置设定在比现有<code>最大自增ID</code>的位置远一些，但必须在一、二两台<code>MySQL实例</code>ID还没有增长到<code>第三台MySQL实例</code>的<code>起始ID</code>值的时候，否则<code>自增ID</code>就要出现重复了，<strong>必要时可能还需要停机修改</strong>。</p><p><strong>优点：</strong></p><ul><li>解决DB单点问题</li></ul><p><strong>缺点：</strong></p><ul><li>不利于后续扩容，而且实际上单个数据库自身压力还是大，依旧无法满足高并发场景。</li></ul><p><strong>4、基于数据库的号段模式</strong></p><p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：</p><pre><code class="hljs java"><span class="hljs-function">CREATE TABLE <span class="hljs-title">id_generator</span> <span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  id <span class="hljs-keyword">int</span>(<span class="hljs-number">10</span>)</span> NOT NULL,</span><span class="hljs-function">  max_id <span class="hljs-title">bigint</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span> NOT NULL COMMENT '当前最大id',</span><span class="hljs-function">  step <span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span> NOT NULL COMMENT '号段的布长',</span><span class="hljs-function">  biz_type<span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span> NOT NULL COMMENT '业务类型',</span><span class="hljs-function">  version <span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span> NOT NULL COMMENT '版本号',</span><span class="hljs-function">  PRIMARY <span class="hljs-title">KEY</span> <span class="hljs-params">(`id`)</span></span><span class="hljs-function">)</span></code></pre><p>biz_type ：代表不同业务类型</p><p>max_id ：当前最大的可用id</p><p>step ：代表号段的长度</p><p>version ：是一个乐观锁，每次都更新version，保证并发时数据的正确性</p><p><img src="https://pic3.zhimg.com/80/v2-abc2633c6ff85daf95fca018f717a24e_720w.png" srcset="/img/loading.gif" alt="img"></p><p>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id= max_id + step</code>，update成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。</p><pre><code class="hljs java">update id_generator set max_id = #&#123;max_id+step&#125;, version = version + 1 where version = # &#123;version&#125; and biz_type = XXX</code></pre><p>由于多业务端可能同时操作，所以采用版本号<code>version</code>乐观锁方式更新，这种<code>分布式ID</code>生成方式不强依赖于数据库，不会频繁的访问数据库，对数据库的压力小很多。</p><p><strong>5、基于Redis模式</strong></p><p><code>Redis</code>也同样可以实现，原理就是利用<code>redis</code>的 <code>incr</code>命令实现ID的原子性自增。</p><pre><code class="hljs java"><span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; set seq_id <span class="hljs-number">1</span>     <span class="hljs-comment">// 初始化自增ID为1</span>OK<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">6379</span>&gt; incr seq_id      <span class="hljs-comment">// 增加1，并返回递增后的数值</span>(integer) <span class="hljs-number">2</span></code></pre><p>用<code>redis</code>实现需要注意一点，要考虑到redis持久化的问题。<code>redis</code>有两种持久化方式<code>RDB</code>和<code>AOF</code></p><ul><li><code>RDB</code>会定时打一个快照进行持久化，假如连续自增但<code>redis</code>没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li><li><code>AOF</code>会对每条写命令进行持久化，即使<code>Redis</code>挂掉了也不会出现ID重复的情况，但由于incr命令的特殊性，会导致<code>Redis</code>重启恢复的数据时间过长。</li></ul><p><strong>6、基于雪花算法（Snowflake）模式</strong></p><p>雪花算法（Snowflake）是twitter公司内部分布式项目采用的ID生成算法，开源后广受国内大厂的好评，在该算法影响下各大公司相继开发出各具特色的分布式生成器。</p><p><img src="https://pic2.zhimg.com/80/v2-4f51c7b6704323cc376b5a8a9a7cad09_720w.jpg" srcset="/img/loading.gif" alt="img">图片源自网络，如有侵权联系删除</p><p><code>Snowflake</code>生成的是Long类型的ID，一个Long类型占8个字节，每个字节占8比特，也就是说一个Long类型占64个比特。</p><p>Snowflake ID组成结构：<code>正数位</code>（占1比特）+ <code>时间戳</code>（占41比特）+ <code>机器ID</code>（占5比特）+ <code>数据中心</code>（占5比特）+ <code>自增值</code>（占12比特），总共64比特组成的一个Long类型。</p><ul><li>第一个bit位（1bit）：Java中long的最高位是符号位代表正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0。</li><li>时间戳部分（41bit）：毫秒级的时间，不建议存当前时间戳，而是用（当前时间戳 - 固定开始时间戳）的差值，可以使产生的ID从更小的值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li><li>工作机器id（10bit）：也被叫做<code>workId</code>，这个可以灵活配置，机房或者机器号组合都可以。</li><li>序列号部分（12bit），自增值支持同一毫秒内同一个节点可以生成4096个ID</li></ul><p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p><p><strong>Java版本的<code>Snowflake</code>算法实现：</strong></p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Twitter的SnowFlake算法,使用SnowFlake算法生成一个整数，然后转化为62进制变成一个短地址URL</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * https://github.com/beyondfengyu/SnowFlake</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SnowFlakeShortUrl</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 起始的时间戳</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> START_TIMESTAMP = <span class="hljs-number">1480166465631L</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每一部分占用的位数</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> SEQUENCE_BIT = <span class="hljs-number">12</span>;   <span class="hljs-comment">//序列号占用的位数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> MACHINE_BIT = <span class="hljs-number">5</span>;     <span class="hljs-comment">//机器标识占用的位数</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> DATA_CENTER_BIT = <span class="hljs-number">5</span>; <span class="hljs-comment">//数据中心占用的位数</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每一部分的最大值</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> MAX_SEQUENCE = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; SEQUENCE_BIT);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> MAX_MACHINE_NUM = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; MACHINE_BIT);    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> MAX_DATA_CENTER_NUM = -<span class="hljs-number">1L</span> ^ (-<span class="hljs-number">1L</span> &lt;&lt; DATA_CENTER_BIT);    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每一部分向左的位移</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> MACHINE_LEFT = SEQUENCE_BIT;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> dataCenterId;  <span class="hljs-comment">//数据中心</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> machineId;     <span class="hljs-comment">//机器标识</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequence = <span class="hljs-number">0L</span>; <span class="hljs-comment">//序列号</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastTimeStamp = -<span class="hljs-number">1L</span>;  <span class="hljs-comment">//上一次时间戳</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getNextMill</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> mill = getNewTimeStamp();        <span class="hljs-keyword">while</span> (mill &lt;= lastTimeStamp) &#123;            mill = getNewTimeStamp();        &#125;        <span class="hljs-keyword">return</span> mill;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getNewTimeStamp</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> System.currentTimeMillis();    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据指定的数据中心ID和机器标志ID生成指定的序列号</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> dataCenterId 数据中心ID</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> machineId    机器标志ID</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SnowFlakeShortUrl</span><span class="hljs-params">(<span class="hljs-keyword">long</span> dataCenterId, <span class="hljs-keyword">long</span> machineId)</span> </span>&#123;        <span class="hljs-keyword">if</span> (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"DtaCenterId can't be greater than MAX_DATA_CENTER_NUM or less than 0！"</span>);        &#125;        <span class="hljs-keyword">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"MachineId can't be greater than MAX_MACHINE_NUM or less than 0！"</span>);        &#125;        <span class="hljs-keyword">this</span>.dataCenterId = dataCenterId;        <span class="hljs-keyword">this</span>.machineId = machineId;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 产生下一个ID</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">long</span> currTimeStamp = getNewTimeStamp();        <span class="hljs-keyword">if</span> (currTimeStamp &lt; lastTimeStamp) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Clock moved backwards.  Refusing to generate id"</span>);        &#125;        <span class="hljs-keyword">if</span> (currTimeStamp == lastTimeStamp) &#123;            <span class="hljs-comment">//相同毫秒内，序列号自增</span>            sequence = (sequence + <span class="hljs-number">1</span>) &amp; MAX_SEQUENCE;            <span class="hljs-comment">//同一毫秒的序列数已经达到最大</span>            <span class="hljs-keyword">if</span> (sequence == <span class="hljs-number">0L</span>) &#123;                currTimeStamp = getNextMill();            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//不同毫秒内，序列号置为0</span>            sequence = <span class="hljs-number">0L</span>;        &#125;        lastTimeStamp = currTimeStamp;        <span class="hljs-keyword">return</span> (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT <span class="hljs-comment">//时间戳部分</span>                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       <span class="hljs-comment">//数据中心部分</span>                | machineId &lt;&lt; MACHINE_LEFT             <span class="hljs-comment">//机器标识部分</span>                | sequence;                             <span class="hljs-comment">//序列号部分</span>    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SnowFlakeShortUrl snowFlake = <span class="hljs-keyword">new</span> SnowFlakeShortUrl(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>); i++) &#123;            <span class="hljs-comment">//10进制</span>            System.out.println(snowFlake.nextId());        &#125;    &#125;&#125;</code></pre><p><strong>7、百度（uid-generator）</strong></p><p><code>uid-generator</code>是由百度技术部开发，项目GitHub地址 <a href="https://link.zhihu.com/?target=https%3A//github.com/baidu/uid-generator">github.com/baidu/uid-g…</a></p><p><code>uid-generator</code>是基于<code>Snowflake</code>算法实现的，与原始的<code>snowflake</code>算法不同在于，<code>uid-generator</code>支持自<code>定义时间戳</code>、<code>工作机器ID</code>和 <code>序列号</code> 等各部分的位数，而且<code>uid-generator</code>中采用用户自定义<code>workId</code>的生成策略。</p><p><code>uid-generator</code>需要与数据库配合使用，需要新增一个<code>WORKER_NODE</code>表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的<code>workId</code>数据由host，port组成。</p><p><strong>对于<code>uid-generator</code> ID组成结构</strong>：</p><p><code>workId</code>，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的<code>snowflake</code>不太一样，时间的单位是秒，而不是毫秒，<code>workId</code>也不一样，而且同一应用每次重启就会消费一个<code>workId</code>。</p><blockquote><p>参考文献 <a href="https://link.zhihu.com/?target=https%3A//github.com/baidu/uid-generator/blob/master/README.zh_cn.md">github.com/baidu/uid-g…</a></p></blockquote><p><strong>8、美团（Leaf）</strong></p><p><code>Leaf</code>由美团开发，github地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/Meituan-Dianping/Leaf">github.com/Meituan-Dia…</a></p><p><code>Leaf</code>同时支持号段模式和<code>snowflake</code>算法模式，可以切换使用。</p><p>号段模式</p><p>先导入源码 <a href="https://link.zhihu.com/?target=https%3A//github.com/Meituan-Dianping/Leaf">github.com/Meituan-Dia…</a> ，在建一张表<code>leaf_alloc</code></p><pre><code class="hljs java">DROP TABLE IF EXISTS `leaf_alloc`;CREATE TABLE `leaf_alloc` (  `biz_tag` varchar(<span class="hljs-number">128</span>)  NOT NULL DEFAULT <span class="hljs-string">''</span> COMMENT <span class="hljs-string">'业务key'</span>,  `max_id` bigint(<span class="hljs-number">20</span>) NOT NULL DEFAULT <span class="hljs-string">'1'</span> COMMENT <span class="hljs-string">'当前已经分配了的最大id'</span>,  `step` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) NOT NULL COMMENT <span class="hljs-string">'初始步长，也是动态调整的最小步长'</span>,  `description` varchar(<span class="hljs-number">256</span>)  DEFAULT NULL COMMENT <span class="hljs-string">'业务key的描述'</span>,  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT <span class="hljs-string">'数据库维护的更新时间'</span>,  <span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span> <span class="hljs-params">(`biz_tag`)</span></span><span class="hljs-function">) ENGINE</span>=InnoDB;</code></pre><p>然后在项目中开启<code>号段模式</code>，配置对应的数据库信息，并关闭<code>snowflake</code>模式</p><pre><code class="hljs java">leaf.name=com.sankuai.leaf.opensource.testleaf.segment.enable=<span class="hljs-keyword">true</span>leaf.jdbc.url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/leaf_test?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8</span>leaf.jdbc.username=rootleaf.jdbc.password=rootleaf.snowflake.enable=<span class="hljs-keyword">false</span>#leaf.snowflake.zk.address=#leaf.snowflake.port=</code></pre><p>启动<code>leaf-server</code> 模块的 <code>LeafServerApplication</code>项目就跑起来了</p><p>号段模式获取分布式自增ID的测试url ：http：<a href="https://link.zhihu.com/?target=https%3A//localhost/">//localhost</a>：8080/api/segment/get/leaf-segment-test</p><p>监控号段模式：<a href="https://link.zhihu.com/?target=http%3A//localhost%3A8080/cache">http://localhost:8080/cache</a></p><p>snowflake模式</p><p><code>Leaf</code>的snowflake模式依赖于<code>ZooKeeper</code>，不同于<code>原始snowflake</code>算法也主要是在<code>workId</code>的生成上，<code>Leaf</code>中<code>workId</code>是基于<code>ZooKeeper</code>的顺序Id来生成的，每个应用在使用<code>Leaf-snowflake</code>时，启动时都会都在<code>Zookeeper</code>中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个<code>workId</code>。</p><pre><code class="hljs java">leaf.snowflake.enable=<span class="hljs-keyword">true</span>leaf.snowflake.zk.address=<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>leaf.snowflake.port=<span class="hljs-number">2181</span></code></pre><p>snowflake模式获取分布式自增ID的测试url：<a href="https://link.zhihu.com/?target=http%3A//localhost%3A8080/api/snowflake/get/test">http://localhost:8080/api/snowflake/get/test</a></p><p><strong>9、滴滴（Tinyid）</strong></p><p><code>Tinyid</code>由滴滴开发，Github地址：<a href="https://link.zhihu.com/?target=https%3A//github.com/didi/tinyid%E3%80%82">github.com/didi/tinyid…</a></p><p><code>Tinyid</code>是基于号段模式原理实现的与<code>Leaf</code>如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]</p><p><img src="https://pic4.zhimg.com/80/v2-7a6aeaa5cde957a95985553912c6435f_720w.jpg" srcset="/img/loading.gif" alt="img"></p><p><code>Tinyid</code>提供<code>http</code>和<code>tinyid-client</code>两种方式接入</p><p>Http方式接入</p><p>（1）导入Tinyid源码：</p><p>git clone <a href="https://link.zhihu.com/?target=https%3A//github.com/didi/tinyid.git">github.com/didi/tinyid…</a></p><p>（2）创建数据表：</p><pre><code class="hljs java">CREATE TABLE `tiny_id_info` (  `id` bigint(<span class="hljs-number">20</span>) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="hljs-string">'自增主键'</span>,  `biz_type` varchar(<span class="hljs-number">63</span>) NOT NULL DEFAULT <span class="hljs-string">''</span> COMMENT <span class="hljs-string">'业务类型，唯一'</span>,  `begin_id` bigint(<span class="hljs-number">20</span>) NOT NULL DEFAULT <span class="hljs-string">'0'</span> COMMENT <span class="hljs-string">'开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同'</span>,  `max_id` bigint(<span class="hljs-number">20</span>) NOT NULL DEFAULT <span class="hljs-string">'0'</span> COMMENT <span class="hljs-string">'当前最大id'</span>,  `step` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) DEFAULT <span class="hljs-string">'0'</span> COMMENT <span class="hljs-string">'步长'</span>,  `delta` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) NOT NULL DEFAULT <span class="hljs-string">'1'</span> COMMENT <span class="hljs-string">'每次id增量'</span>,  `remainder` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) NOT NULL DEFAULT <span class="hljs-string">'0'</span> COMMENT <span class="hljs-string">'余数'</span>,  `create_time` timestamp NOT NULL DEFAULT <span class="hljs-string">'2010-01-01 00:00:00'</span> COMMENT <span class="hljs-string">'创建时间'</span>,  `update_time` timestamp NOT NULL DEFAULT <span class="hljs-string">'2010-01-01 00:00:00'</span> COMMENT <span class="hljs-string">'更新时间'</span>,  `version` bigint(<span class="hljs-number">20</span>) NOT NULL DEFAULT <span class="hljs-string">'0'</span> COMMENT <span class="hljs-string">'版本号'</span>,  <span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span> <span class="hljs-params">(`id`)</span>,</span><span class="hljs-function">  UNIQUE KEY `uniq_biz_type` <span class="hljs-params">(`biz_type`)</span></span><span class="hljs-function">) ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="hljs-number">1</span> DEFAULT CHARSET=utf8 COMMENT <span class="hljs-string">'id信息表'</span>;CREATE TABLE `tiny_id_token` (  `id` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) unsigned NOT NULL AUTO_INCREMENT COMMENT <span class="hljs-string">'自增id'</span>,  `token` varchar(<span class="hljs-number">255</span>) NOT NULL DEFAULT <span class="hljs-string">''</span> COMMENT <span class="hljs-string">'token'</span>,  `biz_type` varchar(<span class="hljs-number">63</span>) NOT NULL DEFAULT <span class="hljs-string">''</span> COMMENT <span class="hljs-string">'此token可访问的业务类型标识'</span>,  `remark` varchar(<span class="hljs-number">255</span>) NOT NULL DEFAULT <span class="hljs-string">''</span> COMMENT <span class="hljs-string">'备注'</span>,  `create_time` timestamp NOT NULL DEFAULT <span class="hljs-string">'2010-01-01 00:00:00'</span> COMMENT <span class="hljs-string">'创建时间'</span>,  `update_time` timestamp NOT NULL DEFAULT <span class="hljs-string">'2010-01-01 00:00:00'</span> COMMENT <span class="hljs-string">'更新时间'</span>,  <span class="hljs-function">PRIMARY <span class="hljs-title">KEY</span> <span class="hljs-params">(`id`)</span></span><span class="hljs-function">) ENGINE</span>=InnoDB AUTO_INCREMENT=<span class="hljs-number">1</span> DEFAULT CHARSET=utf8 COMMENT <span class="hljs-string">'token信息表'</span>;INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)VALUES(<span class="hljs-number">1</span>, <span class="hljs-string">'test'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'2018-07-21 23:52:58'</span>, <span class="hljs-string">'2018-07-22 23:19:27'</span>, <span class="hljs-number">1</span>);INSERT INTO `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)VALUES(<span class="hljs-number">2</span>, <span class="hljs-string">'test_odd'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-string">'2018-07-21 23:52:58'</span>, <span class="hljs-string">'2018-07-23 00:39:24'</span>, <span class="hljs-number">3</span>);INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)VALUES(<span class="hljs-number">1</span>, <span class="hljs-string">'0f673adf80504e2eaa552f5d791b644c'</span>, <span class="hljs-string">'test'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2017-12-14 16:36:46'</span>, <span class="hljs-string">'2017-12-14 16:36:48'</span>);INSERT INTO `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)VALUES(<span class="hljs-number">2</span>, <span class="hljs-string">'0f673adf80504e2eaa552f5d791b644c'</span>, <span class="hljs-string">'test_odd'</span>, <span class="hljs-string">'1'</span>, <span class="hljs-string">'2017-12-14 16:36:46'</span>, <span class="hljs-string">'2017-12-14 16:36:48'</span>);</code></pre><p>（3）配置数据库：</p><pre><code class="hljs java">datasource.tinyid.names=primarydatasource.tinyid.primary.driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span></span>=com.mysql.jdbc.Driverdatasource.tinyid.primary.url=jdbc:mysql:<span class="hljs-comment">//ip:port/databaseName?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span>datasource.tinyid.primary.username=rootdatasource.tinyid.primary.password=<span class="hljs-number">123456</span></code></pre><p>（4）启动<code>tinyid-server</code>后测试</p><pre><code class="hljs java">获取分布式自增ID: http:<span class="hljs-comment">//localhost:9999/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c'</span>返回结果: <span class="hljs-number">3</span>批量获取分布式自增ID:http:<span class="hljs-comment">//localhost:9999/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c&amp;batchSize=10'</span>返回结果:  <span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span></code></pre><p>Java客户端方式接入</p><p>重复Http方式的（2）（3）操作</p><p>引入依赖</p><pre><code class="hljs java">&lt;dependency&gt;     &lt;groupId&gt;com.xiaoju.uemc.tinyid&lt;/groupId&gt;     &lt;artifactId&gt;tinyid-client&lt;/artifactId&gt;     &lt;version&gt;$&#123;tinyid.version&#125;&lt;/version&gt; &lt;/dependency&gt;</code></pre><p>配置文件</p><pre><code class="hljs java">tinyid.server =localhost:<span class="hljs-number">9999</span>tinyid.token =<span class="hljs-number">0f</span>673adf80504e2eaa552f5d791b644c</code></pre><p><code>test</code> 、<code>tinyid.token</code>是在数据库表中预先插入的数据，<code>test</code> 是具体业务类型，<code>tinyid.token</code>表示可访问的业务类型</p><pre><code class="hljs java"><span class="hljs-comment">// 获取单个分布式自增ID</span>Long id =  TinyId . nextId( <span class="hljs-string">" test "</span> );<span class="hljs-comment">// 按需批量分布式自增ID</span>List&lt; Long &gt; ids =  TinyId . nextId( <span class="hljs-string">" test "</span> , <span class="hljs-number">10</span> );</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文只是简单介绍一下每种分布式ID生成器，旨在给大家一个详细学习的方向，每种生成方式都有它自己的优缺点，具体如何使用还要看具体的业务需求。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>window</title>
    <link href="/2020/08/12/window/"/>
    <url>/2020/08/12/window/</url>
    
    <content type="html"><![CDATA[<h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>查看占用端口</p><blockquote><p>netstat -ano | findstr 8121</p></blockquote><p>杀掉占用端口</p><blockquote><p>taskkill -PID 17848 -F    (-F 强制)</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>idea插件</title>
    <link href="/2020/08/12/idea%E6%8F%92%E4%BB%B6/"/>
    <url>/2020/08/12/idea%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><strong>CamelCase</strong></p><p>简介：在几种字符串格式之间来回切换。有一下几种格式：</p><ul><li>驼峰，第一个单词首字母小写，其他单词首字母大写</li><li>所有字母小写，单词间下划线分隔</li><li>所有字母小写，单词间空格分隔</li><li>所有字母小写，单词间短横线分隔</li><li>每个单词首字母全部大写</li><li>所有字母大写，单词间下划线分隔</li></ul><p>使用：按住Shift + Alt再不停的按U，会把选中内容的单词的下划线转驼峰转大写等，不停的转换，直到你想要的。</p><p><strong>RestfulToolkit</strong></p><p>简介：搜索URL，准确的说是搜索SpringMVC项目里，Controller层的@RequestMapping里的URL，通过URL匹配到相应的Controller层方法</p><p><strong>Leetcode Editor</strong></p><p>简介：LeetCode插件，可以在IDEA中在线刷题。上班摸鱼属实方便，表面上我在干活，实际上我在刷算法题。</p><p><strong>Translation</strong></p><p>简介：翻译插件，支持google翻译、百度翻译、有道翻译。</p><p>使用：快捷键Ctrl + Shift + O</p><p><strong>google-java-format 代码自动格式化</strong></p><p>简介：google-java-format插件可以帮助我们不通过对应的快捷键就可以实现特定方式下自动格式化代码。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>docker</title>
    <link href="/2020/08/12/docker/"/>
    <url>/2020/08/12/docker/</url>
    
    <content type="html"><![CDATA[<h2 id="sdas"><a href="#sdas" class="headerlink" title="sdas"></a>sdas</h2><p>​    <img src="/12/docker/image-20200521092906572.png" srcset="/img/loading.gif" alt="image-20200521092906572">docker  run -d  –name <name> </name></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Untitled 1</title>
    <link href="/2020/08/12/Untitled%201/"/>
    <url>/2020/08/12/Untitled%201/</url>
    
    <content type="html"><![CDATA[<p>##</p><h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>24 | 3年经验|13011109541</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2020/08/12/JVM/"/>
    <url>/2020/08/12/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p><img src="/12/JVM/image-20200628185416427.png" srcset="/img/loading.gif" alt="image-20200628185416427"></p><p><img src="/12/JVM/image-20200630162039061.png" srcset="/img/loading.gif" alt="image-20200630162039061"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap</title>
    <link href="/2020/08/12/HashMap/"/>
    <url>/2020/08/12/HashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>Java7</p><p>数组 + 链表</p><p>Java8</p><p>数组 + 链表 + 红黑树</p><p>默认初始值容量16   必须是2的指数幂 </p><p>13  —&gt; 16</p><p>7 —-&gt;8</p><p>3—–&gt;4 </p><p>不是，会默认转化为最接近的2的指数幂</p><p>Java7链表插入 头插法</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git的四个组成部分</title>
    <link href="/2020/08/12/Git%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/"/>
    <url>/2020/08/12/Git%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Git的四个组成部分</strong></p></blockquote><p><img src="/12/Git%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86/640.webp" srcset="/img/loading.gif" alt="img"></p><p>1、初始化仓库</p><pre><code class="hljs ebnf"><span class="hljs-attribute">git init</span></code></pre><p>2、将文件添加到仓库</p><pre><code class="hljs dockerfile">git <span class="hljs-keyword">add</span><span class="bash"> 文件名 <span class="hljs-comment"># 将工作区的某个文件添加到暂存区</span></span>git <span class="hljs-keyword">add</span><span class="bash"> -u <span class="hljs-comment"># 添加所有被tracked文件中被修改或删除的文件信息到暂存区，不处理untracked的文件</span></span>git <span class="hljs-keyword">add</span><span class="bash"> -A <span class="hljs-comment"># 添加所有被tracked文件中被修改或删除的文件信息到暂存区，包括untracked的文件</span></span>git <span class="hljs-keyword">add</span><span class="bash"> . <span class="hljs-comment"># 将当前工作区的所有文件都加入暂存区</span></span>git <span class="hljs-keyword">add</span><span class="bash"> -i <span class="hljs-comment"># 进入交互界面模式，按需添加文件到缓存区</span></span></code></pre><p>3、将暂存区文件提交到本地仓库</p><pre><code class="hljs sql">git <span class="hljs-keyword">commit</span> -m <span class="hljs-string">"提交说明"</span> <span class="hljs-comment"># 将暂存区内容提交到本地仓库</span>git <span class="hljs-keyword">commit</span> -a -m <span class="hljs-string">"提交说明"</span> <span class="hljs-comment"># 跳过缓存区操作，直接把工作区内容提交到本地仓库</span></code></pre><p>4、查看仓库当前状态</p><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span></code></pre><p>5、比较文件异同</p><pre><code class="hljs mipsasm">git <span class="hljs-keyword">diff </span><span class="hljs-comment"># 工作区与暂存区的差异</span>git <span class="hljs-keyword">diff </span>分支名 <span class="hljs-comment">#工作区与某分支的差异，远程分支这样写：remotes/origin/分支名</span>git <span class="hljs-keyword">diff </span>HEAD  <span class="hljs-comment"># 工作区与HEAD指针指向的内容差异</span>git <span class="hljs-keyword">diff </span>提交id 文件路径 <span class="hljs-comment"># 工作区某文件当前版本与历史版本的差异</span>git <span class="hljs-keyword">diff </span>--stage <span class="hljs-comment"># 工作区文件与上次提交的差异(1.6 版本前用 --cached)</span>git <span class="hljs-keyword">diff </span>版本TAG <span class="hljs-comment"># 查看从某个版本后都改动内容</span>git <span class="hljs-keyword">diff </span>分支A 分支<span class="hljs-keyword">B </span><span class="hljs-comment"># 比较从分支A和分支B的差异(也支持比较两个TAG)</span>git <span class="hljs-keyword">diff </span>分支A...分支<span class="hljs-keyword">B </span><span class="hljs-comment"># 比较两分支在分开后各自的改动</span><span class="hljs-comment"># 另外：如果只想统计哪些文件被改动，多少行被改动，可以添加 --stat 参数</span></code></pre><p>6、查看历史记录</p><pre><code class="hljs perl">git <span class="hljs-keyword">log</span> <span class="hljs-comment"># 查看所有commit记录(SHA-A校验和，作者名称，邮箱，提交时间，提交说明)</span>git <span class="hljs-keyword">log</span> -p -次数 <span class="hljs-comment"># 查看最近多少次的提交记录</span>git <span class="hljs-keyword">log</span> --<span class="hljs-keyword">stat</span> <span class="hljs-comment"># 简略显示每次提交的内容更改</span>git <span class="hljs-keyword">log</span> --name-only <span class="hljs-comment"># 仅显示已修改的文件清单</span>git <span class="hljs-keyword">log</span> --name-status <span class="hljs-comment"># 显示新增，修改，删除的文件清单</span>git <span class="hljs-keyword">log</span> --oneline <span class="hljs-comment"># 让提交记录以精简的一行输出</span>git <span class="hljs-keyword">log</span> –graph –all --online <span class="hljs-comment"># 图形展示分支的合并历史</span>git <span class="hljs-keyword">log</span> --author=作者  <span class="hljs-comment"># 查询作者的提交记录(和grep同时使用要加一个--all--match参数)</span>git <span class="hljs-keyword">log</span> --<span class="hljs-keyword">grep</span>=过滤信息 <span class="hljs-comment"># 列出提交信息中包含过滤信息的提交记录</span>git <span class="hljs-keyword">log</span> -S查询内容 <span class="hljs-comment"># 和--grep类似，S和查询内容间没有空格</span>git <span class="hljs-keyword">log</span> fileName <span class="hljs-comment"># 查看某文件的修改记录，找背锅专用</span></code></pre><p>7、代码回滚</p><pre><code class="hljs sql">git <span class="hljs-keyword">reset</span> <span class="hljs-keyword">HEAD</span>^ <span class="hljs-comment"># 恢复成上次提交的版本</span>git <span class="hljs-keyword">reset</span> <span class="hljs-keyword">HEAD</span>^^ <span class="hljs-comment"># 恢复成上上次提交的版本，就是多个^，以此类推或用~次数</span>git refloggit <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard 版本号</span><span class="hljs-comment">--soft：只是改变HEAD指针指向，缓存区和工作区不变；</span><span class="hljs-comment">--mixed：修改HEAD指针指向，暂存区内容丢失，工作区不变；</span><span class="hljs-comment">--hard：修改HEAD指针指向，暂存区内容丢失，工作区恢复以前状态；</span></code></pre><p>8、同步远程仓库</p><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> master</code></pre><p>9、删除版本库文件</p><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> rm 文件名</code></pre><p>10、版本库里的版本替换工作区的版本</p><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- test.txt</span></code></pre><p>11、本地仓库内容推送到远程仓库</p><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="bash"> origin git@github.com:帐号名/仓库名.git</span></code></pre><p>12、从远程仓库克隆项目到本地</p><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">git</span>@github.com:git帐号名/仓库名.git</code></pre><p>13、创建分支</p><pre><code class="hljs q">git checkout -b <span class="hljs-built_in">dev</span>-b表示创建并切换分支上面一条命令相当于一面的二条：git branch <span class="hljs-built_in">dev</span> <span class="hljs-comment">//创建分支</span>git checkout <span class="hljs-built_in">dev</span> <span class="hljs-comment">//切换分支</span></code></pre><p>14、查看分支</p><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span></code></pre><p>15、合并分支</p><pre><code class="hljs stata">git <span class="hljs-keyword">merge</span> dev<span class="hljs-comment">//用于合并指定分支到当前分支</span>git <span class="hljs-keyword">merge</span> --<span class="hljs-keyword">no</span>-ff -<span class="hljs-keyword">m</span> <span class="hljs-string">"merge with no-ff"</span> dev<span class="hljs-comment">//加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并</span></code></pre><p>16、删除分支</p><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">branch </span>-d dev</code></pre><p>17、查看分支合并图</p><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--graph --pretty=oneline --abbrev-commit</span></code></pre><p>18、查看远程库信息</p><pre><code class="hljs 1c">git remote<span class="hljs-comment">// -v 显示更详细的信息</span></code></pre><p>19、git相关配置</p><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 安装完Git后第一件要做的事，设置用户信息(global可换成local在单独项目生效)：</span>git config <span class="hljs-params">--global</span> user.name <span class="hljs-string">"用户名"</span> <span class="hljs-comment"># 设置用户名</span>git config <span class="hljs-params">--global</span> user.email <span class="hljs-string">"用户邮箱"</span>   <span class="hljs-comment">#设置邮箱</span>git config <span class="hljs-params">--global</span> user.name   <span class="hljs-comment"># 查看用户名是否配置成功</span>git config <span class="hljs-params">--global</span> user.email   <span class="hljs-comment"># 查看邮箱是否配置</span><span class="hljs-comment"># 其他查看配置相关</span>git config <span class="hljs-params">--global</span> <span class="hljs-params">--list</span>  <span class="hljs-comment"># 查看全局设置相关参数列表</span>git config <span class="hljs-params">--local</span> <span class="hljs-params">--list</span> <span class="hljs-comment"># 查看本地设置相关参数列表</span>git config <span class="hljs-params">--system</span> <span class="hljs-params">--list</span> <span class="hljs-comment"># 查看系统配置参数列表</span>git config <span class="hljs-params">--list</span>  <span class="hljs-comment"># 查看所有Git的配置(全局+本地+系统)</span>git config <span class="hljs-params">--global</span> color.ui <span class="hljs-literal">true</span> <span class="hljs-string">//</span>显示git相关颜色</code></pre><p>20、撤消某次提交</p><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> revert HEAD <span class="hljs-comment"># 撤销最近的一个提交</span>git revert 版本号 <span class="hljs-comment"># 撤销某次commit</span></code></pre><p>21、拉取远程分支到本地仓库</p><pre><code class="hljs mipsasm">git checkout -<span class="hljs-keyword">b </span>本地分支 远程分支 <span class="hljs-comment"># 会在本地新建分支，并自动切换到该分支</span>git fetch <span class="hljs-keyword">origin </span>远程分支:本地分支 <span class="hljs-comment"># 会在本地新建分支，但不会自动切换，还需checkout</span>git <span class="hljs-keyword">branch </span>--set-upstream 本地分支 远程分支 <span class="hljs-comment"># 建立本地分支与远程分支的链接</span></code></pre><p>22、标签命令</p><pre><code class="hljs crmsh">git <span class="hljs-keyword">tag</span> <span class="hljs-title">标签 //打标签命令，默认为HEAD</span>git <span class="hljs-keyword">tag</span> <span class="hljs-title">//显示所有标签</span><span class="hljs-title">git</span> <span class="hljs-keyword">tag</span> <span class="hljs-title">标签 �版本号 //给某个commit</span>版本添加标签git show 标签 //显示某个标签的详细信息</code></pre><p>23、同步远程仓库更新</p><pre><code class="hljs crmsh">git fetch  origin <span class="hljs-literal">master</span> //从远程获取最新的到本地，首先从远程的origin的<span class="hljs-literal">master</span>主分支下载最新的版本到origin/<span class="hljs-literal">master</span>分支上，然后比较本地的<span class="hljs-literal">master</span>分支和origin/<span class="hljs-literal">master</span>分支的差别，最后进行合并。git fetch比git pull更加安全</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo</title>
    <link href="/2020/08/12/Dubbo/"/>
    <url>/2020/08/12/Dubbo/</url>
    
    <content type="html"><![CDATA[<p><img src="/12/Dubbo/image-20200603160646473.png" srcset="/img/loading.gif" alt="image-20200603160646473"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2018/11/11/Git/"/>
    <url>/2018/11/11/Git/</url>
    
    <content type="html"><![CDATA[<!-- more --><h5 id="1-初始化仓库"><a href="#1-初始化仓库" class="headerlink" title="1.初始化仓库"></a>1.初始化仓库</h5><pre><code class="hljs ebnf"><span class="hljs-attribute">git init</span></code></pre><h5 id="2-文件添加到仓库"><a href="#2-文件添加到仓库" class="headerlink" title="2.文件添加到仓库"></a>2.文件添加到仓库</h5><pre><code class="hljs livecodeserver">git <span class="hljs-built_in">add</span> &lt;<span class="hljs-built_in">file</span>&gt;             （&lt;<span class="hljs-built_in">file</span>&gt; <span class="hljs-comment">---&gt; 指的文件名）</span></code></pre><h5 id="3-文件提交到仓库"><a href="#3-文件提交到仓库" class="headerlink" title="3.文件提交到仓库"></a>3.文件提交到仓库</h5><pre><code class="hljs xml">git commit -m <span class="hljs-tag">&lt;<span class="hljs-name">message</span>&gt;</span>    （-m 后面输入的是本次提交的说明）</code></pre><h5 id="4-仓库的状态"><a href="#4-仓库的状态" class="headerlink" title="4.仓库的状态"></a>4.仓库的状态</h5><pre><code class="hljs ebnf"><span class="hljs-attribute">git status</span></code></pre><h5 id="5-查看修改内容"><a href="#5-查看修改内容" class="headerlink" title="5.查看修改内容"></a>5.查看修改内容</h5><pre><code class="hljs applescript">git diff &lt;<span class="hljs-built_in">file</span>&gt;            （&lt;<span class="hljs-built_in">file</span>&gt; <span class="hljs-comment">---&gt; 不写默认看所有的）</span></code></pre><h5 id="6-查看提交历史"><a href="#6-查看提交历史" class="headerlink" title="6.查看提交历史"></a>6.查看提交历史</h5><pre><code class="hljs applescript">git <span class="hljs-built_in">log</span> <span class="hljs-comment">--pretty=oneline   （--pretty=oneline可以不加）</span></code></pre><h5 id="7-回退到上一版本"><a href="#7-回退到上一版本" class="headerlink" title="7.回退到上一版本"></a>7.回退到上一版本</h5><pre><code class="hljs angelscript">git reset --hard HEAD^      (上一版本是HEAD^，上上一个版本是HEAD^^，往上<span class="hljs-number">100</span>写成HEAD~<span class="hljs-number">100</span>  HEAD^可换成指定的版本号)</code></pre><h5 id="8-查看命令历史"><a href="#8-查看命令历史" class="headerlink" title="8.查看命令历史"></a>8.查看命令历史</h5><pre><code class="hljs angelscript">git <span class="hljs-built_in">ref</span>log</code></pre><h5 id="9-丢弃工作区修改"><a href="#9-丢弃工作区修改" class="headerlink" title="9.丢弃工作区修改"></a>9.丢弃工作区修改</h5><pre><code class="hljs ada">git checkout <span class="hljs-comment">-- &lt;file&gt;</span></code></pre><h5 id="10-丢弃暂存区修改"><a href="#10-丢弃暂存区修改" class="headerlink" title="10.丢弃暂存区修改"></a>10.丢弃暂存区修改</h5><pre><code class="hljs sql">git <span class="hljs-keyword">reset</span> <span class="hljs-keyword">HEAD</span> &lt;<span class="hljs-keyword">file</span>&gt;</code></pre><h5 id="11-关联远程仓库"><a href="#11-关联远程仓库" class="headerlink" title="11.关联远程仓库"></a>11.关联远程仓库</h5><p>git remote add origin <a href="https://github.com/仓库/仓库名" target="_blank" rel="noopener">https://github.com/仓库/仓库名</a>       </p><p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p><ol start="12"><li><h5 id="合并指定分支到当前分支"><a href="#合并指定分支到当前分支" class="headerlink" title="合并指定分支到当前分支"></a>合并指定分支到当前分支</h5><p>git merge</p></li><li><h5 id="Git鼓励大量使用分支："><a href="#Git鼓励大量使用分支：" class="headerlink" title="Git鼓励大量使用分支："></a>Git鼓励大量使用分支：</h5><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="/2018/11/11/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2018/11/11/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="IDEA快捷键"><a href="#IDEA快捷键" class="headerlink" title="IDEA快捷键"></a>IDEA快捷键</h3><h5 id="1-实现接口方法"><a href="#1-实现接口方法" class="headerlink" title="1.实现接口方法"></a>1.实现接口方法</h5><pre><code class="hljs java">Ctrl + I</code></pre><h5 id="2-显示类之间的关系"><a href="#2-显示类之间的关系" class="headerlink" title="2.显示类之间的关系"></a>2.显示类之间的关系</h5><pre><code class="hljs java">Ctrl + Alt + U</code></pre><h5 id="3-idea-调出版本控制操作"><a href="#3-idea-调出版本控制操作" class="headerlink" title="3.idea 调出版本控制操作"></a>3.idea 调出版本控制操作</h5><pre><code class="hljs java">Alt + ~</code></pre><h5 id="4-查看代码注释"><a href="#4-查看代码注释" class="headerlink" title="4.查看代码注释"></a>4.查看代码注释</h5><pre><code class="hljs nginx"><span class="hljs-attribute">Ctrl</span> + Q</code></pre><h5 id="5-查找子类实现"><a href="#5-查找子类实现" class="headerlink" title="5.查找子类实现"></a>5.查找子类实现</h5><pre><code class="hljs nginx"><span class="hljs-attribute">Ctrl</span> + Alt + B</code></pre><h5 id="6-展开目录"><a href="#6-展开目录" class="headerlink" title="6.展开目录"></a>6.展开目录</h5><pre><code class="hljs plain">→   （若展开所有一直按）</code></pre>]]></content>
    
    
    <categories>
      
      <category>IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识微服务02</title>
    <link href="/2018/11/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/"/>
    <url>/2018/11/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/</url>
    
    <content type="html"><![CDATA[<h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>会配置Hystix熔断</li><li>会使用Feign进行远程调用</li><li>能独立搭建Zuul网关</li><li>能编写Zuul的拦截器</li></ul><h1 id="1-Hystix"><a href="#1-Hystix" class="headerlink" title="1.Hystix"></a>1.Hystix</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h2><p>Hystix，即熔断器。</p><p>主页：<a href="https://github.com/Netflix/Hystrix/" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/</a></p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658740266.png" srcset="/img/loading.gif" alt="1525658740266"></p><p>Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658562507.png" srcset="/img/loading.gif" alt="1525658562507"></p><h2 id="1-2-熔断器的工作机制："><a href="#1-2-熔断器的工作机制：" class="headerlink" title="1.2.熔断器的工作机制："></a>1.2.熔断器的工作机制：</h2><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658640314.png" srcset="/img/loading.gif" alt="1525658640314"></p><p>正常工作的情况下，客户端请求调用服务API接口：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658906255.png" srcset="/img/loading.gif" alt="1525658906255"></p><p>当有服务出现异常时，直接进行失败回滚，服务降级处理：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658983518.png" srcset="/img/loading.gif" alt="1525658983518"></p><p>当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。</p><p>这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。</p><p>系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。</p><h2 id="1-3-动手实践"><a href="#1-3-动手实践" class="headerlink" title="1.3.动手实践"></a>1.3.动手实践</h2><h3 id="1-3-1-引入依赖"><a href="#1-3-1-引入依赖" class="headerlink" title="1.3.1.引入依赖"></a>1.3.1.引入依赖</h3><p>首先在user-consumer中引入Hystix依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="1-3-2-开启熔断"><a href="#1-3-2-开启熔断" class="headerlink" title="1.3.2.开启熔断"></a>1.3.2.开启熔断</h3><h3 id="1-3-2-改造消费者"><a href="#1-3-2-改造消费者" class="headerlink" title="1.3.2.改造消费者"></a>1.3.2.改造消费者</h3><p>我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数：</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(UserDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"queryUserByIdFallback"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Long id)</span></span>&#123;        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();        String url = <span class="hljs-string">"http://user-service/user/"</span> + id;        User user = <span class="hljs-keyword">this</span>.restTemplate.getForObject(url, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();        <span class="hljs-comment">// 记录访问用时：</span>        logger.info(<span class="hljs-string">"访问用时：&#123;&#125;"</span>, end - begin);        <span class="hljs-keyword">return</span> user;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserByIdFallback</span><span class="hljs-params">(Long id)</span></span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(id);        user.setName(<span class="hljs-string">"用户信息查询出现异常！"</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre><ul><li><code>@HystrixCommand(fallbackMethod=&quot;queryUserByIdFallback&quot;)</code>：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</li><li>为了方便查看熔断的触发时机，我们记录请求访问时间。</li></ul><p>在原来的业务逻辑中调用这个DAO：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserDao userDao;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        ids.forEach(id -&gt; &#123;            <span class="hljs-comment">// 我们测试多次查询，</span>            users.add(<span class="hljs-keyword">this</span>.userDao.queryUserById(id));        &#125;);        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre><h3 id="1-3-3-改造服务提供者"><a href="#1-3-3-改造服务提供者" class="headerlink" title="1.3.3.改造服务提供者"></a>1.3.3.改造服务提供者</h3><p>改造服务提供者，随机休眠一段时间，以触发熔断：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">// 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒</span>        Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">2000</span>));        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userMapper.selectByPrimaryKey(id);    &#125;&#125;</code></pre><h3 id="1-3-4-启动测试"><a href="#1-3-4-启动测试" class="headerlink" title="1.3.4.启动测试"></a>1.3.4.启动测试</h3><p>然后运行并查看日志：</p><p>id为9、10、11的访问时间分别是：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525661641660.png" srcset="/img/loading.gif" alt="1525661641660"></p><p>id为12的访问时间：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525661669136.png" srcset="/img/loading.gif" alt="1525661669136"></p><p>因此，只有12是正常访问，其它都会触发熔断，我们来查看结果：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525661720656.png" srcset="/img/loading.gif" alt="1525661720656"></p><h3 id="1-3-5-优化"><a href="#1-3-5-优化" class="headerlink" title="1.3.5.优化"></a>1.3.5.优化</h3><p>虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？</p><p>其实这里是因为我们的Ribbon超时时间设置的是1000ms:</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525666632542.png" srcset="/img/loading.gif" alt="1525666632542"></p><p>而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。</p><p>所以，Ribbon的超时时间一定要小于Hystix的超时时间。</p><p>我们可以通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>来设置Hystrix超时时间。</p><pre><code class="hljs yaml"><span class="hljs-attr">hystrix:</span>  <span class="hljs-attr">command:</span>  <span class="hljs-attr">default:</span>        <span class="hljs-attr">execution:</span>          <span class="hljs-attr">isolation:</span>            <span class="hljs-attr">thread:</span>              <span class="hljs-attr">timeoutInMillisecond:</span> <span class="hljs-number">6000</span> <span class="hljs-comment"># 设置hystrix的超时时间为6000ms</span></code></pre><h1 id="2-Feign"><a href="#2-Feign" class="headerlink" title="2.Feign"></a>2.Feign</h1><p>在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：</p><pre><code class="hljs java">String baseUrl = <span class="hljs-string">"http://user-service/user/"</span>;User user = <span class="hljs-keyword">this</span>.restTemplate.getForObject(baseUrl + id, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span></code></pre><p>如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？</p><p>这就是我们接下来要学的Feign的功能了。</p><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1.简介"></a>2.1.简介</h2><p>有道词典的英文解释：</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525662976679.png" srcset="/img/loading.gif" alt="1525662976679"></p><p>为什么叫伪装？</p><p>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。</p><p>项目主页：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525652009416.png" srcset="/img/loading.gif" alt="1525652009416"></p><h2 id="2-2-快速入门"><a href="#2-2-快速入门" class="headerlink" title="2.2.快速入门"></a>2.2.快速入门</h2><h3 id="2-2-1-导入依赖"><a href="#2-2-1-导入依赖" class="headerlink" title="2.2.1.导入依赖"></a>2.2.1.导入依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="2-2-2-Feign的客户端"><a href="#2-2-2-Feign的客户端" class="headerlink" title="2.2.2.Feign的客户端"></a>2.2.2.Feign的客户端</h3><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(<span class="hljs-string">"user-service"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;"</span>)    <span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;&#125;</code></pre><ul><li>首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像</li><li><code>@FeignClient</code>，声明这是一个Feign客户端，类似<code>@Mapper</code>注解。同时通过<code>value</code>属性指定服务名称</li><li>接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果</li></ul><p>改造原来的调用逻辑，不再调用UserDao：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserFeignClient userFeignClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        ids.forEach(id -&gt; &#123;            <span class="hljs-comment">// 我们测试多次查询，</span>            users.add(<span class="hljs-keyword">this</span>.userFeignClient.queryUserById(id));        &#125;);        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre><h3 id="2-2-3-开启Feign功能"><a href="#2-2-3-开启Feign功能" class="headerlink" title="2.2.3.开启Feign功能"></a>2.2.3.开启Feign功能</h3><p>我们在启动类上，添加注解，开启Feign功能</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@EnableHystrix</span><span class="hljs-meta">@EnableFeignClients</span> <span class="hljs-comment">// 开启Feign功能</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConsumerDemoApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(UserConsumerDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><ul><li>你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了</li></ul><h3 id="2-2-4-启动测试："><a href="#2-2-4-启动测试：" class="headerlink" title="2.2.4.启动测试："></a>2.2.4.启动测试：</h3><p>访问接口：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525666476326.png" srcset="/img/loading.gif" alt="1525666476326"></p><p>正常获取到了结果。</p><h2 id="2-3-负载均衡"><a href="#2-3-负载均衡" class="headerlink" title="2.3.负载均衡"></a>2.3.负载均衡</h2><p>Feign中本身已经集成了Ribbon依赖和自动配置：</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525672070679.png" srcset="/img/loading.gif" alt="1525672070679"></p><p>因此我们不需要额外引入依赖，也不需要再注册<code>RestTemplate</code>对象。</p><p>另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过<code>ribbon.xx</code>来进行全局配置。也可以通过<code>服务名.ribbon.xx</code>来对指定服务配置：</p><pre><code class="hljs yaml"><span class="hljs-attr">user-service:</span>  <span class="hljs-attr">ribbon:</span>    <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># 连接超时时间(ms)</span>    <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># 通信超时时间(ms)</span>    <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作重试</span>    <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一服务不同实例的重试次数</span>    <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一实例的重试次数</span></code></pre><h2 id="2-4-Hystix支持"><a href="#2-4-Hystix支持" class="headerlink" title="2.4.Hystix支持"></a>2.4.Hystix支持</h2><p>Feign默认也有对Hystix的集成：</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525672466192.png" srcset="/img/loading.gif" alt="1525672466192"></p><p>只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：</p><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <span class="hljs-attr">hystrix:</span>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启Feign的熔断功能</span></code></pre><p>但是，Feign中的Fallback配置不像Ribbon中那样简单了。</p><p>1）首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFeignClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(id);        user.setName(<span class="hljs-string">"用户查询出现异常！"</span>);        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre><p>2）然后在UserFeignClient中，指定刚才编写的实现类</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"user-service"</span>, fallback = UserFeignClientFallback<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;"</span>)    <span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;&#125;</code></pre><p>3）重启测试：</p><p>我们关闭user-service服务，然后在页面访问：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525673049875.png" srcset="/img/loading.gif" alt="1525673049875"></p><h2 id="2-5-请求压缩-了解"><a href="#2-5-请求压缩-了解" class="headerlink" title="2.5.请求压缩(了解)"></a>2.5.请求压缩(了解)</h2><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：</p><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <span class="hljs-attr">compression:</span>    <span class="hljs-attr">request:</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启请求压缩</span>    <span class="hljs-attr">response:</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启响应压缩</span></code></pre><p>同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>  <span class="hljs-attr">compression:</span>    <span class="hljs-attr">request:</span>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启请求压缩</span>      <span class="hljs-attr">mime-types:</span> <span class="hljs-string">text/html,application/xml,application/json</span> <span class="hljs-comment"># 设置压缩的数据类型</span>      <span class="hljs-attr">min-request-size:</span> <span class="hljs-number">2048</span> <span class="hljs-comment"># 设置触发压缩的大小下限</span></code></pre><p>注：上面的数据类型、压缩大小下限均为默认值。</p><h2 id="2-6-日志级别-了解"><a href="#2-6-日志级别-了解" class="headerlink" title="2.6.日志级别(了解)"></a>2.6.日志级别(了解)</h2><p>前面讲过，通过<code>logging.level.xx=debug</code>来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p><p>1）设置com.leyou包下的日志级别都为debug</p><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span>  <span class="hljs-attr">level:</span>    <span class="hljs-attr">com.leyou:</span> <span class="hljs-string">debug</span></code></pre><p>2）编写配置类，定义日志级别</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> Logger.Level.FULL;    &#125;&#125;</code></pre><p>这里指定的Level级别是FULL，Feign支持4种级别：</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525674373507.png" srcset="/img/loading.gif" alt="1525674373507"></p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>3）在FeignClient中指定配置类：</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"user-service"</span>, fallback = UserFeignClientFallback<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">configuration</span> </span>= FeignConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;"</span>)    <span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;&#125;</code></pre><p>4）重启项目，即可看到每次访问的日志：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525674544569.png" srcset="/img/loading.gif" alt="1525674544569"></p><h1 id="3-Zuul网关"><a href="#3-Zuul网关" class="headerlink" title="3.Zuul网关"></a>3.Zuul网关</h1><p>通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525674644660.png" srcset="/img/loading.gif" alt="1525674644660"></p><p>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</p><p>在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？</p><p>先来说说这样架构需要做的一些事儿以及存在的不足：</p><ul><li>首先，破坏了服务无状态特点。<ul><li>为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。</li><li>从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。</li></ul></li><li>其次，无法直接复用既有接口。<ul><li>当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</li></ul></li></ul><p>面对类似上面的问题，我们要如何解决呢？答案是：服务网关！</p><p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。</p><p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了<code>权限控制</code>等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p><h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h2><p>官网：<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">https://github.com/Netflix/zuul</a></p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675037152.png" srcset="/img/loading.gif" alt="1525675037152"></p><p>Zuul：维基百科：</p><p>电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。</p><p>事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675168152.png" srcset="/img/loading.gif" alt="1525675168152"></p><h2 id="3-2-Zuul加入后的架构"><a href="#3-2-Zuul加入后的架构" class="headerlink" title="3.2.Zuul加入后的架构"></a>3.2.Zuul加入后的架构</h2><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675648881.png" srcset="/img/loading.gif" alt="1525675648881"></p><ul><li>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</li></ul><h2 id="3-3-快速入门"><a href="#3-3-快速入门" class="headerlink" title="3.3.快速入门"></a>3.3.快速入门</h2><h3 id="3-3-1-新建工程"><a href="#3-3-1-新建工程" class="headerlink" title="3.3.1.新建工程"></a>3.3.1.新建工程</h3><p>填写基本信息：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675928548.png" srcset="/img/loading.gif" alt="1525675928548"></p><p>添加Zuul依赖：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675991833.png" srcset="/img/loading.gif" alt="1525675991833"></p><h3 id="3-3-2-编写启动类"><a href="#3-3-2-编写启动类" class="headerlink" title="3.3.2.编写启动类"></a>3.3.2.编写启动类</h3><p>通过<code>@EnableZuulProxy</code>注解开启Zuul的功能：</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableZuulProxy</span> <span class="hljs-comment">// 开启Zuul的网关功能</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZuulDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(ZuulDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre><h3 id="3-3-3-编写配置"><a href="#3-3-3-编写配置" class="headerlink" title="3.3.3.编写配置"></a>3.3.3.编写配置</h3><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment">#服务端口</span><span class="hljs-attr">spring:</span>   <span class="hljs-attr">application:</span>      <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span> <span class="hljs-comment">#指定服务名</span></code></pre><h3 id="3-3-4-编写路由规则"><a href="#3-3-4-编写路由规则" class="headerlink" title="3.3.4.编写路由规则"></a>3.3.4.编写路由规则</h3><p>我们需要用Zuul来代理user-service服务，先看一下控制面板中的服务状态：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525676797879.png" srcset="/img/loading.gif" alt="1525676797879"></p><ul><li>ip为：127.0.0.1</li><li>端口为：8081</li></ul><p>映射规则：</p><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">routes:</span>    <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span>      <span class="hljs-attr">url:</span> <span class="hljs-string">http://127.0.0.1:8081</span> <span class="hljs-comment"># 映射路径对应的实际url地址</span></code></pre><p>我们将符合<code>path</code> 规则的一切请求，都代理到 <code>url</code>参数指定的地址</p><p>本例中，我们将 <code>/user-service/**</code>开头的请求，代理到<a href="http://127.0.0.1:8081" target="_blank" rel="noopener">http://127.0.0.1:8081</a></p><h3 id="3-3-5-启动测试："><a href="#3-3-5-启动测试：" class="headerlink" title="3.3.5.启动测试："></a>3.3.5.启动测试：</h3><p>访问的路径中需要加上配置规则的映射路径，我们访问：<a href="http://127.0.0.1:8081/user-service/user/10" target="_blank" rel="noopener">http://127.0.0.1:8081/user-service/user/10</a></p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525677046705.png" srcset="/img/loading.gif" alt="1525677046705"></p><h2 id="3-4-面向服务的路由"><a href="#3-4-面向服务的路由" class="headerlink" title="3.4.面向服务的路由"></a>3.4.面向服务的路由</h2><p>在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。</p><p>我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！</p><h3 id="3-4-1-添加Eureka客户端依赖"><a href="#3-4-1-添加Eureka客户端依赖" class="headerlink" title="3.4.1.添加Eureka客户端依赖"></a>3.4.1.添加Eureka客户端依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h3 id="3-4-2-开启Eureka客户端发现功能"><a href="#3-4-2-开启Eureka客户端发现功能" class="headerlink" title="3.4.2.开启Eureka客户端发现功能"></a>3.4.2.开启Eureka客户端发现功能</h3><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableZuulProxy</span> <span class="hljs-comment">// 开启Zuul的网关功能</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZuulDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(ZuulDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre><h3 id="3-4-3-添加Eureka配置，获取服务信息"><a href="#3-4-3-添加Eureka配置，获取服务信息" class="headerlink" title="3.4.3.添加Eureka配置，获取服务信息"></a>3.4.3.添加Eureka配置，获取服务信息</h3><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 获取服务列表的周期：5s</span>    <span class="hljs-attr">service-url:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre><h3 id="3-4-4-修改映射配置，通过服务名称获取"><a href="#3-4-4-修改映射配置，通过服务名称获取" class="headerlink" title="3.4.4.修改映射配置，通过服务名称获取"></a>3.4.4.修改映射配置，通过服务名称获取</h3><p>因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">routes:</span>    <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span>      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 指定服务名称</span></code></pre><h3 id="3-4-5-启动测试"><a href="#3-4-5-启动测试" class="headerlink" title="3.4.5.启动测试"></a>3.4.5.启动测试</h3><p>再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525677821212.png" srcset="/img/loading.gif" alt="1525677821212"></p><p>日志中可以看到使用了负载均衡器：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525677891119.png" srcset="/img/loading.gif" alt="1525677891119"></p><h2 id="3-5-简化的路由配置"><a href="#3-5-简化的路由配置" class="headerlink" title="3.5.简化的路由配置"></a>3.5.简化的路由配置</h2><p>在刚才的配置中，我们的规则是这样的：</p><ul><li><code>zuul.routes.&lt;route&gt;.path=/xxx/**</code>： 来指定映射路径。<code>&lt;route&gt;</code>是自定义的路由名</li><li><code>zuul.routes.&lt;route&gt;.serviceId=/user-service</code>：来指定服务名。</li></ul><p>而大多数情况下，我们的<code>&lt;route&gt;</code>路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></p><p>比方说上面我们关于user-service的配置可以简化为一条：</p><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">routes:</span>    <span class="hljs-attr">user-service:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span></code></pre><p>省去了对服务名称的配置。</p><h2 id="3-6-默认的路由规则"><a href="#3-6-默认的路由规则" class="headerlink" title="3.6.默认的路由规则"></a>3.6.默认的路由规则</h2><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：</p><ul><li>默认情况下，一切服务的映射路径就是服务名本身。<ul><li>例如服务名为：<code>user-service</code>，则默认的映射路径就是：<code>/user-service/**</code></li></ul></li></ul><p>也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。</p><h2 id="3-7-路由前缀"><a href="#3-7-路由前缀" class="headerlink" title="3.7.路由前缀"></a>3.7.路由前缀</h2><p>配置示例：</p><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">prefix:</span> <span class="hljs-string">/api</span> <span class="hljs-comment"># 添加路由前缀</span>  <span class="hljs-attr">routes:</span>      <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span>        <span class="hljs-attr">path:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span>        <span class="hljs-attr">service-id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 指定服务名称</span></code></pre><p>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。</p><p>路径<code>/api/user-service/user/1</code>将会被代理到<code>/user-service/user/1</code></p><h2 id="3-8-过滤器"><a href="#3-8-过滤器" class="headerlink" title="3.8.过滤器"></a>3.8.过滤器</h2><p>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。</p><h3 id="3-8-1-ZuulFilter"><a href="#3-8-1-ZuulFilter" class="headerlink" title="3.8.1.ZuulFilter"></a>3.8.1.ZuulFilter</h3><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ZuulFilter implements IZuulFilter&#123;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span></span>;        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 来自IZuulFilter</span>    <span class="hljs-function">Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException</span>;<span class="hljs-comment">// IZuulFilter</span>&#125;</code></pre><ul><li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li><li><code>run</code>：过滤器的具体业务逻辑。</li><li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul><li><code>pre</code>：请求在被路由之前执行</li><li><code>routing</code>：在路由请求时调用</li><li><code>post</code>：在routing和errror过滤器之后调用</li><li><code>error</code>：处理请求时发生错误调用</li></ul></li><li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li></ul><h3 id="3-8-2-过滤器执行生命周期："><a href="#3-8-2-过滤器执行生命周期：" class="headerlink" title="3.8.2.过滤器执行生命周期："></a>3.8.2.过滤器执行生命周期：</h3><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525681866862.png" srcset="/img/loading.gif" alt="1525681866862"></p><ul><li>正常流程：<ul><li>请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</li></ul></li><li>异常流程：<ul><li>整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</li><li>如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。</li><li>如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。</li></ul></li></ul><p>所有内置过滤器列表：</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525682427811.png" srcset="/img/loading.gif" alt="1525682427811"></p><h3 id="3-8-3-使用场景"><a href="#3-8-3-使用场景" class="headerlink" title="3.8.3.使用场景"></a>3.8.3.使用场景</h3><p>场景非常多：</p><ul><li>请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了</li><li>异常处理：一般会在error类型和post类型过滤器中结合来处理。</li><li>服务调用时长统计：pre和post结合使用。</li></ul><h2 id="3-9-自定义过滤器"><a href="#3-9-自定义过滤器" class="headerlink" title="3.9.自定义过滤器"></a>3.9.自定义过滤器</h2><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p><h3 id="3-9-1-定义过滤器类"><a href="#3-9-1-定义过滤器类" class="headerlink" title="3.9.1.定义过滤器类"></a>3.9.1.定义过滤器类</h3><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 登录校验，肯定是在前置拦截</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">"pre"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 顺序设置为1</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 返回true，代表过滤器生效。</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;        <span class="hljs-comment">// 登录校验逻辑。</span>        <span class="hljs-comment">// 1）获取Zuul提供的请求上下文对象</span>        RequestContext ctx = RequestContext.getCurrentContext();        <span class="hljs-comment">// 2) 从上下文中获取request对象</span>        HttpServletRequest req = ctx.getRequest();        <span class="hljs-comment">// 3) 从请求中获取token</span>        String token = req.getParameter(<span class="hljs-string">"access-token"</span>);        <span class="hljs-comment">// 4) 判断</span>        <span class="hljs-keyword">if</span>(token == <span class="hljs-keyword">null</span> || <span class="hljs-string">""</span>.equals(token.trim()))&#123;            <span class="hljs-comment">// 没有token，登录校验失败，拦截</span>            ctx.setSendZuulResponse(<span class="hljs-keyword">false</span>);            <span class="hljs-comment">// 返回401状态码。也可以考虑重定向到登录页。</span>            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());        &#125;        <span class="hljs-comment">// 校验通过，可以考虑把用户信息放入上下文，继续向后执行</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h3 id="3-9-2-测试"><a href="#3-9-2-测试" class="headerlink" title="3.9.2.测试"></a>3.9.2.测试</h3><p>没有token参数时，访问失败：</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525683285697.png" srcset="/img/loading.gif" alt="1525683285697"></p><p>添加token参数后：</p><p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525683354113.png" srcset="/img/loading.gif" alt="1525683354113"></p><h2 id="3-10-负载均衡和熔断"><a href="#3-10-负载均衡和熔断" class="headerlink" title="3.10.负载均衡和熔断"></a>3.10.负载均衡和熔断</h2><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p><pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>  <span class="hljs-attr">retryable:</span> <span class="hljs-literal">true</span><span class="hljs-attr">ribbon:</span>  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># 连接超时时间(ms)</span>  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">2000</span> <span class="hljs-comment"># 通信超时时间(ms)</span>  <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作重试</span>  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 同一服务不同实例的重试次数</span>  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一实例的重试次数</span><span class="hljs-attr">hystrix:</span>  <span class="hljs-attr">command:</span>  <span class="hljs-attr">default:</span>        <span class="hljs-attr">execution:</span>          <span class="hljs-attr">isolation:</span>            <span class="hljs-attr">thread:</span>              <span class="hljs-attr">timeoutInMillisecond:</span> <span class="hljs-number">6000</span> <span class="hljs-comment"># 熔断超时时长：6000ms</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL调优</title>
    <link href="/2018/11/10/SQL%E8%B0%83%E4%BC%98/"/>
    <url>/2018/11/10/SQL%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1.索引优化"></a>1.索引优化</h3><blockquote><p>1、创建索引<br>对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。<br>2、复合索引<br>比如有一条语句是这样的：select * from users where area=’beijing’ and age=22;<br>如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用作限制条件的列放在最左边，依次递减。<br>3、索引不会包含有NULL值的列<br>只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。<br>4、使用短索引<br>对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。<br>5、排序的索引问题<br>mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。<br>6、like语句操作<br>一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。<br>7、不要在列上进行运算<br>select * from users where YEAR(adddate)&lt;2007;<br>将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成<br>select * from users where adddate&lt;‘2007-01-01’;<br>8、不使用NOT IN和&lt;&gt;操作<br>NOT IN和&lt;&gt;操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id&lt;&gt;3则可使用id&gt;3 or id&lt;3来代替。</p></blockquote><h3 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h3><p>1.明知只有一条查询结果，那请使用 “LIMIT 1”。“LIMIT 1”可以避免全表扫描，找到对应结果就不会再继续扫描了</p><p>2.尽量避免使用 “SELECT *”。如果不查询表中所有的列，尽量避免使用 SELECT *，因为它需要先查询 table meta，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络IO开销。</p><p>3.使用 EXPLAIN 关键字去查看执行计划。EXPLAIN 可以检查索引使用情况以及扫描的行。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识微服务01</title>
    <link href="/2018/11/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/"/>
    <url>/2018/11/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/</url>
    
    <content type="html"><![CDATA[<h1 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h1><ul><li>了解系统架构的演变</li><li>了解RPC与Http的区别</li><li>掌握HttpClient的简单使用</li><li>知道什么是SpringCloud</li><li>独立搭建Eureka注册中心</li><li>独立配置Robbin负载均衡</li></ul><p>-Xms128m -Xmx128m</p><h1 id="1-系统架构演变"><a href="#1-系统架构演变" class="headerlink" title="1.系统架构演变"></a>1.系统架构演变</h1><p>随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？</p><p>其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。</p><h2 id="1-1-集中式架构"><a href="#1-1-集中式架构" class="headerlink" title="1.1. 集中式架构"></a>1.1. 集中式架构</h2><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525529091749.png" srcset="/img/loading.gif" alt="1525529091749"></p><p>存在的问题：</p><ul><li>代码耦合，开发维护困难</li><li>无法针对不同模块进行针对性优化</li><li>无法水平扩展</li><li>单点容错率低，并发能力差</li></ul><h2 id="1-2-垂直拆分"><a href="#1-2-垂直拆分" class="headerlink" title="1.2.垂直拆分"></a>1.2.垂直拆分</h2><p>当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525529671801.png" srcset="/img/loading.gif" alt="1525529671801"></p><p>优点：</p><ul><li>系统拆分实现了流量分担，解决了并发问题</li><li>可以针对不同模块进行优化</li><li>方便水平扩展，负载均衡，容错率提高</li></ul><p>缺点：</p><ul><li>系统间相互独立，会有很多重复开发工作，影响开发效率</li></ul><h2 id="1-3-分布式服务"><a href="#1-3-分布式服务" class="headerlink" title="1.3.分布式服务"></a>1.3.分布式服务</h2><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525530657919.png" srcset="/img/loading.gif" alt="1525530657919"></p><p>优点：</p><ul><li>将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</li></ul><p>缺点：</p><ul><li>系统间耦合度变高，调用关系错综复杂，难以维护</li></ul><h2 id="1-4-服务治理（SOA）"><a href="#1-4-服务治理（SOA）" class="headerlink" title="1.4.服务治理（SOA）"></a>1.4.服务治理（SOA）</h2><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525530804753.png" srcset="/img/loading.gif" alt="1525530804753"></p><p>以前出现了什么问题？</p><ul><li>服务越来越多，需要管理每个服务的地址</li><li>调用关系错综复杂，难以理清依赖关系</li><li>服务过多，服务状态难以管理，无法根据服务情况动态管理</li></ul><p>服务治理要做什么？</p><ul><li>服务注册中心，实现服务自动注册和发现，无需人为记录服务地址</li><li>服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系</li><li>动态监控服务状态监控报告，人为控制服务状态</li></ul><p>缺点：</p><ul><li>服务间会有依赖关系，一旦某个环节出错会影响较大</li><li>服务关系复杂，运维、测试部署困难，不符合DevOps思想</li></ul><h2 id="1-5-微服务"><a href="#1-5-微服务" class="headerlink" title="1.5.微服务"></a>1.5.微服务</h2><p>前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525532344817.png" srcset="/img/loading.gif" alt="1525532344817"></p><p>微服务的特点：</p><ul><li>单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li><li>微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li><li>面向服务：面向服务是说每个服务都要对外暴露服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。</li><li>自治：自治是说服务间互相独立，互不干扰<ul><li>团队独立：每个服务都是一个独立的开发团队，人数不能过多。</li><li>技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉</li><li>前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口</li><li>数据库分离：每个服务都使用自己的数据源</li><li>部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护</li></ul></li></ul><p>微服务结构图：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1526860071166.png" srcset="/img/loading.gif" alt="1526860071166"></p><h1 id="2-远程调用方式"><a href="#2-远程调用方式" class="headerlink" title="2.远程调用方式"></a>2.远程调用方式</h1><p>无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？</p><p>常见的远程调用方式有以下几种：</p><ul><li><p>RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型</p></li><li><p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。</p><p>现在热门的Rest风格，就可以通过http协议来实现。</p></li></ul><h2 id="2-1-认识RPC"><a href="#2-1-认识RPC" class="headerlink" title="2.1.认识RPC"></a>2.1.认识RPC</h2><p>RPC，即 Remote Procedure Call（远程过程调用），是一个计算机通信协议。 该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。说得通俗一点就是：A计算机提供一个服务，B计算机可以像调用本地服务那样调用A计算机的服务。</p><p>通过上面的概念，我们可以知道，实现RPC主要是做到两点： </p><ul><li>实现远程调用其他计算机的服务<ul><li>要实现远程调用，肯定是通过网络传输数据。A程序提供服务，B程序通过网络将请求参数传递给A，A本地执行后得到结果，再将结果返回给B程序。这里需要关注的有两点：<ul><li>1）采用何种网络通讯协议？<ul><li>现在比较流行的RPC框架，都会采用TCP作为底层传输协议</li></ul></li><li>2）数据传输的格式怎样？<ul><li>两个程序进行通讯，必须约定好数据传输格式。就好比两个人聊天，要用同一种语言，否则无法沟通。所以，我们必须定义好请求和响应的格式。另外，数据在网路中传输需要进行序列化，所以还需要约定统一的序列化的方式。</li></ul></li></ul></li></ul></li><li>像调用本地服务一样调用远程服务 <ul><li>如果仅仅是远程调用，还不算是RPC，因为RPC强调的是过程调用，调用的过程对用户而言是应该是透明的，用户不应该关心调用的细节，可以像调用本地服务一样调用远程服务。所以RPC一定要对调用的过程进行封装</li></ul></li></ul><p>RPC调用流程图：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525568965976.png" srcset="/img/loading.gif" alt="1525568965976"></p><p>想要了解详细的RPC实现，给大家推荐一篇文章：<a href="https://legacy.gitbook.com/book/huge0612/tour-of-rpc/details" target="_blank" rel="noopener">自己动手实现RPC</a></p><h2 id="2-2-认识Http"><a href="#2-2-认识Http" class="headerlink" title="2.2.认识Http"></a>2.2.认识Http</h2><p>Http协议：超文本传输协议，是一种应用层协议。规定了网络传输的请求格式、响应格式、资源定位和操作的方式等。但是底层采用什么网络传输协议，并没有规定，不过现在都是采用TCP协议作为底层传输协议。说到这里，大家可能觉得，Http与RPC的远程调用非常像，都是按照某种规定好的数据格式进行网络通信，有请求，有响应。没错，在这点来看，两者非常相似，但是还是有一些细微差别。</p><ul><li>RPC并没有规定数据传输格式，这个格式可以任意指定，不同的RPC协议，数据格式不一定相同。</li><li>Http中还定义了资源定位的路径，RPC中并不需要</li><li>最重要的一点：RPC需要满足像调用本地服务一样调用远程服务，也就是对调用过程在API层面进行封装。Http协议没有这样的要求，因此请求、响应等细节需要我们自己去实现。<ul><li>优点：RPC方式更加透明，对用户更方便。Http方式更灵活，没有规定API和语言，跨语言、跨平台</li><li>缺点：RPC方式需要在API层面进行封装，限制了开发的语言环境。</li></ul></li></ul><p>例如我们通过浏览器访问网站，就是通过Http协议。只不过浏览器把请求封装，发起请求以及接收响应，解析响应的事情都帮我们做了。如果是不通过浏览器，那么这些事情都需要自己去完成。</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525569352313.png" srcset="/img/loading.gif" alt="1525569352313"></p><h2 id="2-3-如何选择？"><a href="#2-3-如何选择？" class="headerlink" title="2.3.如何选择？"></a>2.3.如何选择？</h2><p>既然两种方式都可以实现远程调用，我们该如何选择呢？</p><ul><li>速度来看，RPC要比http更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩。</li><li>难度来看，RPC实现较为复杂，http相对比较简单</li><li>灵活性来看，http更胜一筹，因为它不关心实现细节，跨平台、跨语言。</li></ul><p>因此，两者都有不同的使用场景：</p><ul><li>如果对效率要求更高，并且开发过程使用统一的技术栈，那么用RPC还是不错的。</li><li>如果需要更加灵活，跨语言、跨平台，显然http更合适</li></ul><p>那么我们该怎么选择呢？</p><p>微服务，更加强调的是独立、自治、灵活。而RPC方式的限制较多，因此微服务框架中，一般都会采用基于Http的Rest风格服务。</p><h1 id="3-Http客户端工具"><a href="#3-Http客户端工具" class="headerlink" title="3.Http客户端工具"></a>3.Http客户端工具</h1><p>既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：</p><ul><li>HttpClient</li><li>OKHttp</li><li>URLConnection</li></ul><p>接下来，我们就一起了解一款比较流行的客户端工具：HttpClient</p><h2 id="3-1-HttpClient"><a href="#3-1-HttpClient" class="headerlink" title="3.1.HttpClient"></a>3.1.HttpClient</h2><h3 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1.介绍"></a>3.1.1.介绍</h3><p>HttpClient是Apache公司的产品，是Http Components下的一个组件。</p><p><a href="http://hc.apache.org/index.html" target="_blank" rel="noopener">官网地址：http://hc.apache.org/index.html</a></p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525570921966.png" srcset="/img/loading.gif" alt="1525570921966"></p><p>特点：</p><ul><li>基于标准、纯净的Java语言。实现了Http1.0和Http1.1</li><li>以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）</li><li>支持HTTPS协议。</li><li>通过Http代理建立透明的连接。</li><li>自动处理Set-Cookie中的Cookie。</li></ul><h3 id="3-1-2-使用"><a href="#3-1-2-使用" class="headerlink" title="3.1.2.使用"></a>3.1.2.使用</h3><p>我们导入课前资料提供的demo工程：《http-demo》</p><p>发起get请求：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    HttpGet request = <span class="hljs-keyword">new</span> HttpGet(<span class="hljs-string">"http://www.baidu.com"</span>);    String response = <span class="hljs-keyword">this</span>.httpClient.execute(request, <span class="hljs-keyword">new</span> BasicResponseHandler());    System.out.println(response);&#125;</code></pre><p>发起Post请求：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPost</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    HttpPost request = <span class="hljs-keyword">new</span> HttpPost(<span class="hljs-string">"http://www.oschina.net/"</span>);    request.setHeader(<span class="hljs-string">"User-Agent"</span>,                      <span class="hljs-string">"Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36"</span>);    String response = <span class="hljs-keyword">this</span>.httpClient.execute(request, <span class="hljs-keyword">new</span> BasicResponseHandler());    System.out.println(response);&#125;</code></pre><p>尝试访问昨天编写的接口：<a href="http://localhost/hello" target="_blank" rel="noopener">http://localhost/hello</a></p><p>这个接口返回一个User对象</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetPojo</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    HttpGet request = <span class="hljs-keyword">new</span> HttpGet(<span class="hljs-string">"http://localhost/hello"</span>);    String response = <span class="hljs-keyword">this</span>.httpClient.execute(request, <span class="hljs-keyword">new</span> BasicResponseHandler());    System.out.println(response);&#125;</code></pre><p>我们实际得到的是一个json字符串：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">"id"</span>: <span class="hljs-number">8</span>,    <span class="hljs-attr">"userName"</span>: <span class="hljs-string">"liuyan"</span>,    <span class="hljs-attr">"password"</span>: <span class="hljs-string">"123456"</span>,    <span class="hljs-attr">"name"</span>: <span class="hljs-string">"柳岩"</span>,    <span class="hljs-attr">"age"</span>: <span class="hljs-number">21</span>,    <span class="hljs-attr">"sex"</span>: <span class="hljs-number">2</span>,    <span class="hljs-attr">"birthday"</span>: <span class="hljs-string">"1995-08-07T16:00:00.000+0000"</span>,    <span class="hljs-attr">"created"</span>: <span class="hljs-string">"2014-09-20T03:41:15.000+0000"</span>,    <span class="hljs-attr">"updated"</span>: <span class="hljs-string">"2014-09-20T03:41:15.000+0000"</span>,    <span class="hljs-attr">"note"</span>: <span class="hljs-string">"柳岩同学在传智播客学表演"</span>&#125;</code></pre><p>如果想要得到对象，我们还需要手动进行Json反序列化，这一点比较麻烦。</p><h3 id="3-1-3-Json转换工具"><a href="#3-1-3-Json转换工具" class="headerlink" title="3.1.3.Json转换工具"></a>3.1.3.Json转换工具</h3><p>HttpClient请求数据后是json字符串，需要我们自己把Json字符串反序列化为对象，我们会使用JacksonJson工具来实现。</p><p><code>JacksonJson</code>是SpringMVC内置的json处理工具，其中有一个<code>ObjectMapper</code>类，可以方便的实现对json的处理：</p><h4 id="对象转json"><a href="#对象转json" class="headerlink" title="对象转json"></a>对象转json</h4><pre><code class="hljs java"><span class="hljs-comment">// json处理工具</span>    <span class="hljs-keyword">private</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.setId(<span class="hljs-number">8L</span>);        user.setAge(<span class="hljs-number">21</span>);        user.setName(<span class="hljs-string">"柳岩"</span>);        user.setUserName(<span class="hljs-string">"liuyan"</span>);        <span class="hljs-comment">// 序列化</span>        String json = mapper.writeValueAsString(user);        System.out.println(<span class="hljs-string">"json = "</span> + json);    &#125;</code></pre><p>结果：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1526877496885.png" srcset="/img/loading.gif" alt="1526877496885"></p><h4 id="json转普通对象"><a href="#json转普通对象" class="headerlink" title="json转普通对象"></a>json转普通对象</h4><pre><code class="hljs java"><span class="hljs-comment">// json处理工具</span><span class="hljs-keyword">private</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    User user = <span class="hljs-keyword">new</span> User();    user.setId(<span class="hljs-number">8L</span>);    user.setAge(<span class="hljs-number">21</span>);    user.setName(<span class="hljs-string">"柳岩"</span>);    user.setUserName(<span class="hljs-string">"liuyan"</span>);    <span class="hljs-comment">// 序列化</span>    String json = mapper.writeValueAsString(user);    <span class="hljs-comment">// 反序列化，接收两个参数：json数据，反序列化的目标类字节码</span>    User result = mapper.readValue(json, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    System.out.println(<span class="hljs-string">"result = "</span> + result);&#125;</code></pre><p>结果：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1526877647406.png" srcset="/img/loading.gif" alt="1526877647406"></p><h4 id="json转集合"><a href="#json转集合" class="headerlink" title="json转集合"></a>json转集合</h4><p>json转集合比较麻烦，因为你无法同时把集合的class和元素的class同时传递到一个参数。</p><p>因此Jackson做了一个类型工厂，用来解决这个问题：</p><pre><code class="hljs java"><span class="hljs-comment">// json处理工具</span><span class="hljs-keyword">private</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    User user = <span class="hljs-keyword">new</span> User();    user.setId(<span class="hljs-number">8L</span>);    user.setAge(<span class="hljs-number">21</span>);    user.setName(<span class="hljs-string">"柳岩"</span>);    user.setUserName(<span class="hljs-string">"liuyan"</span>);    <span class="hljs-comment">// 序列化,得到对象集合的json字符串</span>    String json = mapper.writeValueAsString(Arrays.asList(user, user));    <span class="hljs-comment">// 反序列化，接收两个参数：json数据，反序列化的目标类字节码</span>    List&lt;User&gt; users = mapper.readValue(json, mapper.getTypeFactory().constructCollectionType(List<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">User</span>.<span class="hljs-title">class</span>))</span>;    <span class="hljs-keyword">for</span> (User u : users) &#123;        System.out.println(<span class="hljs-string">"u = "</span> + u);    &#125;&#125;</code></pre><p>结果：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1526877995530.png" srcset="/img/loading.gif" alt="1526877995530"></p><h4 id="json转任意复杂类型"><a href="#json转任意复杂类型" class="headerlink" title="json转任意复杂类型"></a>json转任意复杂类型</h4><p>当对象泛型关系复杂时，类型工厂也不好使了。这个时候Jackson提供了TypeReference来接收类型泛型，然后底层通过反射来获取泛型上的具体类型。实现数据转换。</p><pre><code class="hljs java"><span class="hljs-comment">// json处理工具</span><span class="hljs-keyword">private</span> ObjectMapper mapper = <span class="hljs-keyword">new</span> ObjectMapper();<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testJson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    User user = <span class="hljs-keyword">new</span> User();    user.setId(<span class="hljs-number">8L</span>);    user.setAge(<span class="hljs-number">21</span>);    user.setName(<span class="hljs-string">"柳岩"</span>);    user.setUserName(<span class="hljs-string">"liuyan"</span>);    <span class="hljs-comment">// 序列化,得到对象集合的json字符串</span>    String json = mapper.writeValueAsString(Arrays.asList(user, user));    <span class="hljs-comment">// 反序列化，接收两个参数：json数据，反序列化的目标类字节码</span>    List&lt;User&gt; users = mapper.readValue(json, <span class="hljs-keyword">new</span> TypeReference&lt;List&lt;User&gt;&gt;()&#123;&#125;);    <span class="hljs-keyword">for</span> (User u : users) &#123;        System.out.println(<span class="hljs-string">"u = "</span> + u);    &#125;&#125;</code></pre><p>结果：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1526877988488.png" srcset="/img/loading.gif" alt="1526877988488"></p><h2 id="3-3-Spring的RestTemplate"><a href="#3-3-Spring的RestTemplate" class="headerlink" title="3.3.Spring的RestTemplate"></a>3.3.Spring的RestTemplate</h2><p>Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：</p><ul><li>HttpClient</li><li>OkHttp</li><li>JDK原生的URLConnection（默认的）</li></ul><p>首先在项目中注册一个<code>RestTemplate</code>对象，可以在启动类位置注册：</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(HttpDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;<span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 默认的RestTemplate，底层是走JDK的URLConnection方式。</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;&#125;</code></pre><p>在测试类中直接<code>@Autowired</code>注入：</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span> </span>= HttpDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">HttpDemoApplicationTests</span> </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> RestTemplate restTemplate;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">httpGet</span><span class="hljs-params">()</span> </span>&#123;User user = <span class="hljs-keyword">this</span>.restTemplate.getForObject(<span class="hljs-string">"http://localhost/hello"</span>, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(user);&#125;&#125;</code></pre><ul><li>通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。</li></ul><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525573702492.png" srcset="/img/loading.gif" alt="1525573702492"></p><p>学习完了Http客户端工具，接下来就可以正式学习微服务了。</p><h1 id="4-初始SpringCloud"><a href="#4-初始SpringCloud" class="headerlink" title="4.初始SpringCloud"></a>4.初始SpringCloud</h1><p>微服务是一种架构方式，最终肯定需要技术架构去实施。</p><p>微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？</p><ul><li>后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。</li><li>技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了</li><li>群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。</li><li>使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建</li></ul><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1.简介"></a>4.1.简介</h2><p>SpringCloud是Spring旗下的项目之一，<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">官网地址：http://projects.spring.io/spring-cloud/</a></p><p>Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。</p><p>SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：</p><p>netflix</p><ul><li>Eureka：注册中心</li><li>Zuul：服务网关</li><li>Ribbon：负载均衡</li><li>Feign：服务调用</li><li>Hystix：熔断器</li></ul><p>以上只是其中一部分，架构图：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525575656796.png" srcset="/img/loading.gif" alt="1525575656796"></p><h2 id="4-2-版本"><a href="#4-2-版本" class="headerlink" title="4.2.版本"></a>4.2.版本</h2><p>SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词组成：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525575903675.png" srcset="/img/loading.gif" alt="1525575903675"></p><p>我们在项目中，会是以Finchley的版本。</p><p>其中包含的组件，也都有各自的版本，如下表：</p><table><thead><tr><th>Component</th><th>Edgware.SR3</th><th>Finchley.RC1</th><th>Finchley.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-bus</td><td>1.3.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cli</td><td>1.4.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-commons</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-contract</td><td>1.2.4.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-config</td><td>1.4.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.4.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-security</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cloudfoundry</td><td>1.1.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-consul</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.3.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR3</td><td>Elmhurst.RELEASE</td><td>Elmhurst.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-boot</td><td>1.5.10.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-task</td><td>1.2.2.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.RELEASE</td></tr><tr><td>spring-cloud-vault</td><td>1.1.0.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.1.RELEASE</td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-openfeign</td><td></td><td>2.0.0.RC1</td><td>2.0.0.BUILD-SNAPSHOT</td></tr></tbody></table><p>接下来，我们就一一学习SpringCloud中的重要组件。</p><h1 id="5-微服务场景模拟"><a href="#5-微服务场景模拟" class="headerlink" title="5.微服务场景模拟"></a>5.微服务场景模拟</h1><p>首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构</p><h2 id="5-1-服务提供者"><a href="#5-1-服务提供者" class="headerlink" title="5.1.服务提供者"></a>5.1.服务提供者</h2><p>我们新建一个项目，对外提供查询用户的服务。</p><h3 id="5-1-1-Spring脚手架创建工程"><a href="#5-1-1-Spring脚手架创建工程" class="headerlink" title="5.1.1.Spring脚手架创建工程"></a>5.1.1.Spring脚手架创建工程</h3><p>借助于Spring提供的快速搭建工具：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525576816916.png" srcset="/img/loading.gif" alt="1525576816916"></p><p>填写项目信息：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525576909381.png" srcset="/img/loading.gif" alt="1525576909381"></p><p>添加web依赖：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525576950842.png" srcset="/img/loading.gif" alt="1525576950842"></p><p>添加mybatis依赖：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525576999052.png" srcset="/img/loading.gif" alt="1525576999052"></p><p>填写项目位置：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525577029150.png" srcset="/img/loading.gif" alt="1525577029150"></p><p>生成的项目结构：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525577106711.png" srcset="/img/loading.gif" alt="1525577106711"></p><p>依赖也已经全部自动引入：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>user-service-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>user-service-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>当然，因为要使用通用mapper，所以我们需要手动加一条依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>tk.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>非常快捷啊！</p><h3 id="5-1-2-编写代码"><a href="#5-1-2-编写代码" class="headerlink" title="5.1.2.编写代码"></a>5.1.2.编写代码</h3><p>添加一个对外查询的接口：</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/&#123;id&#125;"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userService.queryById(id);    &#125;&#125;</code></pre><p>Service：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserMapper userMapper;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userMapper.selectByPrimaryKey(id);    &#125;&#125;</code></pre><p>mapper:</p><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">tk</span>.<span class="hljs-title">mybatis</span>.<span class="hljs-title">mapper</span>.<span class="hljs-title">common</span>.<span class="hljs-title">Mapper</span>&lt;<span class="hljs-title">User</span>&gt;</span>&#123;&#125;</code></pre><p>实体类：</p><pre><code class="hljs java"><span class="hljs-meta">@Table</span>(name = <span class="hljs-string">"tb_user"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;    <span class="hljs-meta">@Id</span>    <span class="hljs-meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)    <span class="hljs-keyword">private</span> Long id;    <span class="hljs-comment">// 用户名</span>    <span class="hljs-keyword">private</span> String userName;    <span class="hljs-comment">// 密码</span>    <span class="hljs-keyword">private</span> String password;    <span class="hljs-comment">// 姓名</span>    <span class="hljs-keyword">private</span> String name;    <span class="hljs-comment">// 年龄</span>    <span class="hljs-keyword">private</span> Integer age;    <span class="hljs-comment">// 性别，1男性，2女性</span>    <span class="hljs-keyword">private</span> Integer sex;    <span class="hljs-comment">// 出生日期</span>    <span class="hljs-keyword">private</span> Date birthday;    <span class="hljs-comment">// 创建时间</span>    <span class="hljs-keyword">private</span> Date created;    <span class="hljs-comment">// 更新时间</span>    <span class="hljs-keyword">private</span> Date updated;    <span class="hljs-comment">// 备注</span>    <span class="hljs-keyword">private</span> String note;   <span class="hljs-comment">// 。。。省略getters和setters</span>&#125;</code></pre><p>属性文件,这里我们采用了yaml语法，而不是properties：</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mydb01</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span>    <span class="hljs-attr">hikari:</span>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">10</span><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.leyou.userservice.pojo</span></code></pre><p>项目结构：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525577911331.png" srcset="/img/loading.gif" alt="1525577911331"></p><h3 id="5-1-3-启动并测试："><a href="#5-1-3-启动并测试：" class="headerlink" title="5.1.3.启动并测试："></a>5.1.3.启动并测试：</h3><p>启动项目，访问接口：<a href="http://localhost:8081/user/7" target="_blank" rel="noopener">http://localhost:8081/user/7</a></p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525593139364.png" srcset="/img/loading.gif" alt="1525593139364"></p><h2 id="5-2-服务调用者"><a href="#5-2-服务调用者" class="headerlink" title="5.2.服务调用者"></a>5.2.服务调用者</h2><h3 id="5-2-1-创建工程"><a href="#5-2-1-创建工程" class="headerlink" title="5.2.1.创建工程"></a>5.2.1.创建工程</h3><p>与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。</p><p>pom：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>user-consumer-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>user-consumer-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 添加OkHttp支持 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><h3 id="5-2-2-编写代码"><a href="#5-2-2-编写代码" class="headerlink" title="5.2.2.编写代码"></a>5.2.2.编写代码</h3><p>首先在启动类中注册<code>RestTemplate</code>：</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConsumerDemoApplication</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 这次我们使用了OkHttp客户端,只需要注入工厂即可</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(UserConsumerDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>然后编写UserDao，注意，这里不是调用mapper查数据库，而是通过RestTemplate远程查询user-service-demo中的接口：</p><pre><code class="hljs java"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Long id)</span></span>&#123;        String url = <span class="hljs-string">"http://localhost:8081/user/"</span> + id;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.restTemplate.getForObject(url, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;&#125;</code></pre><p>然后编写user-service，循环查询UserDAO信息：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserDao userDao;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">querUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span></span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-keyword">for</span> (Long id : ids) &#123;            User user = <span class="hljs-keyword">this</span>.userDao.queryUserById(id);            users.add(user);        &#125;        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre><p>编写controller：</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"consume"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConsumerController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;    <span class="hljs-meta">@GetMapping</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">consume</span><span class="hljs-params">(@RequestParam(<span class="hljs-string">"ids"</span>)</span> List&lt;Long&gt; ids) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userService.queryUserByIds(ids);    &#125;&#125;</code></pre><h3 id="5-2-3-启动测试："><a href="#5-2-3-启动测试：" class="headerlink" title="5.2.3.启动测试："></a>5.2.3.启动测试：</h3><p>因为我们没有配置端口，那么默认就是8080，我们访问：<a href="http://localhost:8080/consume?ids=6,7,8" target="_blank" rel="noopener">http://localhost:8080/consume?ids=6,7,8</a></p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525594222408.png" srcset="/img/loading.gif" alt="1525594222408"></p><p>一个简单的远程服务调用案例就实现了。</p><h2 id="5-3-有没有问题？"><a href="#5-3-有没有问题？" class="headerlink" title="5.3.有没有问题？"></a>5.3.有没有问题？</h2><p>简单回顾一下，刚才我们写了什么：</p><ul><li>use-service-demo：一个提供根据id查询用户的微服务</li><li>consumer-demo：一个服务调用者，通过RestTemplate远程调用user-service-demo</li></ul><p>流程如下：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525595012668.png" srcset="/img/loading.gif" alt="1525595012668"></p><p>存在什么问题？</p><ul><li>在consumer中，我们把url地址硬编码到了代码中，不方便后期维护</li><li>consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效</li><li>consumer不清楚user-service的状态，服务宕机也不知道</li><li>user-service只有1台服务，不具备高可用性</li><li>即便user-service形成集群，consumer还需自己实现负载均衡</li></ul><p>其实上面说的问题，概括一下就是分布式服务必然要面临的问题：</p><ul><li>服务管理<ul><li>如何自动注册和发现</li><li>如何实现状态监管</li><li>如何实现动态路由</li></ul></li><li>服务如何实现负载均衡</li><li>服务如何解决容灾问题</li><li>服务如何实现统一配置</li></ul><p>以上的问题，我们都将在SpringCloud中得到答案。</p><h1 id="6-Eureka注册中心"><a href="#6-Eureka注册中心" class="headerlink" title="6.Eureka注册中心"></a>6.Eureka注册中心</h1><h2 id="6-1-认识Eureka"><a href="#6-1-认识Eureka" class="headerlink" title="6.1.认识Eureka"></a>6.1.认识Eureka</h2><p>首先我们来解决第一问题，服务的管理。</p><blockquote><p>问题分析</p></blockquote><p>在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。</p><blockquote><p>网约车</p></blockquote><p>这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。</p><p>此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。</p><p>此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！</p><blockquote><p>Eureka做什么？</p></blockquote><p>Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。</p><p>同时，服务提供方与Eureka之间通过<code>“心跳”</code>机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。</p><p>这就实现了服务的自动注册、发现、状态监控。</p><h2 id="6-2-原理图"><a href="#6-2-原理图" class="headerlink" title="6.2.原理图"></a>6.2.原理图</h2><blockquote><p>基本架构：</p></blockquote><h1 id><a href="#" class="headerlink" title></a><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525597885059.png" srcset="/img/loading.gif" alt="1525597885059"></h1><ul><li>Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址</li><li>提供者：启动后向Eureka注册自己信息（地址，提供什么服务）</li><li>消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li><li>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</li></ul><h2 id="6-3-入门案例"><a href="#6-3-入门案例" class="headerlink" title="6.3.入门案例"></a>6.3.入门案例</h2><h3 id="6-3-1-编写EurekaServer"><a href="#6-3-1-编写EurekaServer" class="headerlink" title="6.3.1.编写EurekaServer"></a>6.3.1.编写EurekaServer</h3><p>接下来我们创建一个项目，启动一个EurekaServer：</p><p>依然使用spring提供的快速搭建工具：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525598231170.png" srcset="/img/loading.gif" alt="1525598231170"></p><p>选择依赖：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525598312368.png" srcset="/img/loading.gif" alt="1525598312368"></p><p>完整的Pom文件：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.leyou.demo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eureka-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>eureka-demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span>        <span class="hljs-comment">&lt;!-- SpringCloud版本，是最新的F系列 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Finchley.RC1<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!-- Eureka服务端 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-comment">&lt;!-- SpringCloud依赖，一定要放到dependencyManagement中，起到管理版本的作用即可 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>编写启动类：</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span> <span class="hljs-comment">// 声明这个应用是一个EurekaServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(EurekaDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre><p>编写配置：</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span> <span class="hljs-comment"># 端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment"># 应用名称，会在Eureka中显示</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否注册自己的信息到EurekaServer，默认是true</span>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 是否拉取其它服务的信息，默认是true</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要加上其它Server的地址。</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:$&#123;server.port&#125;/eureka</span></code></pre><p>启动服务，并访问：<a href="http://127.0.0.1:10086/eureka" target="_blank" rel="noopener">http://127.0.0.1:10086/eureka</a></p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525604959508.png" srcset="/img/loading.gif" alt="1525604959508"></p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525605081129.png" srcset="/img/loading.gif" alt="1525605081129"></p><h3 id="6-3-2-将user-service注册到Eureka"><a href="#6-3-2-将user-service注册到Eureka" class="headerlink" title="6.3.2.将user-service注册到Eureka"></a>6.3.2.将user-service注册到Eureka</h3><p>注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。</p><blockquote><p>我们在user-service-demo中添加Eureka客户端依赖：</p></blockquote><p>先添加SpringCloud依赖：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringCloud的依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Finchley.RC1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- Spring的仓库地址 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></code></pre><p>然后是Eureka客户端：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Eureka客户端 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><blockquote><p>在启动类上开启Eureka客户端功能</p></blockquote><p>通过添加<code>@EnableDiscoveryClient</code>来开启Eureka客户端功能</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 开启EurekaClient功能</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceDemoApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(UserServiceDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre><blockquote><p>编写配置</p></blockquote><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">datasource:</span>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mydb01</span>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span>    <span class="hljs-attr">password:</span> <span class="hljs-number">123</span>    <span class="hljs-attr">hikari:</span>      <span class="hljs-attr">maximum-pool-size:</span> <span class="hljs-number">20</span>      <span class="hljs-attr">minimum-idle:</span> <span class="hljs-number">10</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 应用名称</span><span class="hljs-attr">mybatis:</span>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.leyou.userservice.pojo</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer地址</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 当调用getHostname获取实例的hostname时，返回ip而不是host名称</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 指定自己的ip信息，不指定的话会自己寻找</span></code></pre><p>注意：</p><ul><li>这里我们添加了spring.application.name属性来指定应用名称，将来会作为应用的id使用。</li><li>不用指定register-with-eureka和fetch-registry，因为默认是true</li></ul><blockquote><p>重启项目，访问<a href="http://127.0.0.1:10086/eureka" target="_blank" rel="noopener">Eureka监控页面</a>查看</p></blockquote><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525609225152.png" srcset="/img/loading.gif" alt="1525609225152"></p><p>我们发现user-service服务已经注册成功了</p><h3 id="6-3-3-消费者从Eureka获取服务"><a href="#6-3-3-消费者从Eureka获取服务" class="headerlink" title="6.3.3.消费者从Eureka获取服务"></a>6.3.3.消费者从Eureka获取服务</h3><p>接下来我们修改consumer-demo，尝试从EurekaServer获取服务。</p><p>方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！</p><p>1）添加依赖：</p><p>先添加SpringCloud依赖：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- SpringCloud的依赖 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Finchley.RC1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><span class="hljs-comment">&lt;!-- Spring的仓库地址 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span></code></pre><p>然后是Eureka客户端：</p><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- Eureka客户端 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>2）在启动类开启Eureka客户端</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span> <span class="hljs-comment">// 开启Eureka客户端</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConsumerDemoApplication</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(UserConsumerDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>3）修改配置：</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">consumer</span> <span class="hljs-comment"># 应用名称</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer地址</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 当其它服务获取地址时提供ip而不是hostname</span>    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <span class="hljs-comment"># 指定自己的ip信息，不指定的话会自己寻找</span></code></pre><p>4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;<span class="hljs-comment">// Eureka客户端，可以获取到服务实例信息</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// String baseUrl = "http://localhost:8081/user/";</span>        <span class="hljs-comment">// 根据服务名称，获取服务实例</span>        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="hljs-string">"user-service"</span>);        <span class="hljs-comment">// 因为只有一个UserService,因此我们直接get(0)获取</span>        ServiceInstance instance = instances.get(<span class="hljs-number">0</span>);        <span class="hljs-comment">// 获取ip和端口信息</span>        String baseUrl = <span class="hljs-string">"http://"</span>+instance.getHost() + <span class="hljs-string">":"</span> + instance.getPort()+<span class="hljs-string">"/user/"</span>;        ids.forEach(id -&gt; &#123;            <span class="hljs-comment">// 我们测试多次查询，</span>            users.add(<span class="hljs-keyword">this</span>.restTemplate.getForObject(baseUrl + id, User<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;            <span class="hljs-comment">// 每次间隔500毫秒</span>            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">500</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre><p>5）Debug跟踪运行：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525613025086.png" srcset="/img/loading.gif" alt="1525613025086"></p><p>生成的URL：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525613051210.png" srcset="/img/loading.gif" alt="1525613051210"></p><p>访问结果：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525613160920.png" srcset="/img/loading.gif" alt="1525613160920"></p><h2 id="6-4-Eureka详解"><a href="#6-4-Eureka详解" class="headerlink" title="6.4.Eureka详解"></a>6.4.Eureka详解</h2><p>接下来我们详细讲解Eureka的原理及配置。</p><h3 id="6-4-1-基础架构"><a href="#6-4-1-基础架构" class="headerlink" title="6.4.1.基础架构"></a>6.4.1.基础架构</h3><p>Eureka架构中的三个核心角色：</p><ul><li><p>服务注册中心</p><p>Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-demo</p></li><li><p>服务提供者</p><p>提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service-demo</p></li><li><p>服务消费者</p><p>消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer-demo</p></li></ul><h3 id="6-4-2-高可用的Eureka-Server"><a href="#6-4-2-高可用的Eureka-Server" class="headerlink" title="6.4.2.高可用的Eureka Server"></a>6.4.2.高可用的Eureka Server</h3><p>Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。</p><blockquote><p>服务同步</p></blockquote><p>多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现<strong>数据同步</strong>。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。</p><blockquote><p>动手搭建高可用的EurekaServer</p></blockquote><p>我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087</p><p>1）我们修改原来的EurekaServer配置：</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10086</span> <span class="hljs-comment"># 端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment"># 应用名称，会在Eureka中显示</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10087/eureka</span></code></pre><p>所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务进行注册，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：</p><ul><li>删除了register-with-eureka=false和fetch-registry=false两个配置。因为默认值是true，这样就会吧自己注册到注册中心了。</li><li>把service-url的值改成了另外一台EurekaServer的地址，而不是自己</li></ul><p>2）另外一台配置恰好相反：</p><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">10087</span> <span class="hljs-comment"># 端口</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">eureka-server</span> <span class="hljs-comment"># 应用名称，会在Eureka中显示</span><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span></code></pre><p>注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525615070033.png" srcset="/img/loading.gif" alt="1525615070033"></p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525615095693.png" srcset="/img/loading.gif" alt="1525615095693"></p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525615026937.png" srcset="/img/loading.gif" alt="1525615026937"></p><p>然后启动即可。</p><p>3）启动测试：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525615165157.png" srcset="/img/loading.gif" alt="1525615165157"></p><p>4）客户端注册服务到集群</p><p>因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">service-url:</span> <span class="hljs-comment"># EurekaServer地址,多个地址以','隔开</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span></code></pre><h3 id="6-4-3-服务提供者"><a href="#6-4-3-服务提供者" class="headerlink" title="6.4.3.服务提供者"></a>6.4.3.服务提供者</h3><p>服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。</p><blockquote><p>服务注册</p></blockquote><p>服务提供者在启动时，会检测配置属性中的：<code>eureka.client.register-with-erueka=true</code>参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。第一层Map的Key就是服务名称，第二层Map的key是服务的实例id。</p><blockquote><p>服务续约</p></blockquote><p>在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；</p><p>有两个重要参数可以修改服务续约的行为：</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">90</span>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">30</span></code></pre><ul><li>lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒</li><li>lease-expiration-duration-in-seconds：服务失效时间，默认值90秒</li></ul><p>也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。</p><p>但是在开发时，这个值有点太长了，经常我们关掉一个服务，会发现Eureka依然认为服务在活着。所以我们在开发阶段可以适当调小。</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">lease-expiration-duration-in-seconds:</span> <span class="hljs-number">10</span> <span class="hljs-comment"># 10秒即过期</span>    <span class="hljs-attr">lease-renewal-interval-in-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 5秒一次心跳</span></code></pre><blockquote><p>实例id</p></blockquote><p>先来看一下服务状态信息：</p><p>在Eureka监控页面，查看服务注册信息：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525617060656.png" srcset="/img/loading.gif" alt="1525617060656"></p><p>在status一列中，显示以下信息：</p><ul><li>UP(1)：代表现在是启动了1个示例，没有集群</li><li>DESKTOP-2MVEC12:user-service:8081：是示例的名称（instance-id），<ul><li>默认格式是：<code>${hostname} + ${spring.application.name} + ${server.port}</code></li><li>instance-id是区分同一服务的不同实例的唯一标准，因此不能重复。</li></ul></li></ul><p>我们可以通过instance-id属性来修改它的构成：</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">instance:</span>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">$&#123;spring.application.name&#125;:$&#123;server.port&#125;</span></code></pre><p>重启服务再试试看：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525617542081.png" srcset="/img/loading.gif" alt="1525617542081"></p><h3 id="6-4-4-服务消费者"><a href="#6-4-4-服务消费者" class="headerlink" title="6.4.4.服务消费者"></a>6.4.4.服务消费者</h3><blockquote><p>获取服务列表</p></blockquote><p>当服务消费者启动是，会检测<code>eureka.client.fetch-registry=true</code>参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且<code>每隔30秒</code>会重新获取并更新数据。我们可以通过下面的参数来修改：</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">5</span></code></pre><p>生产环境中，我们不需要修改这个值。</p><p>但是为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点。</p><h3 id="6-4-5-失效剔除和自我保护"><a href="#6-4-5-失效剔除和自我保护" class="headerlink" title="6.4.5.失效剔除和自我保护"></a>6.4.5.失效剔除和自我保护</h3><blockquote><p>失效剔除</p></blockquote><p>有些时候，我们的服务提供方并不一定会正常下线，可能因为内存溢出、网络故障等原因导致服务无法正常工作。Eureka Server需要将这样的服务剔除出服务列表。因此它会开启一个定时任务，每隔60秒对所有失效的服务（超过90秒未响应）进行剔除。</p><p>可以通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒，生成环境不要修改。</p><p>这个会对我们开发带来极大的不变，你对服务重启，隔了60秒Eureka才反应过来。开发阶段可以适当调整，比如10S</p><blockquote><p>自我保护</p></blockquote><p>我们关停一个服务，就会在Eureka面板看到一条警告：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525618396076.png" srcset="/img/loading.gif" alt="1525618396076"></p><p>这是触发了Eureka的自我保护机制。当一个服务未按时进行心跳续约时，Eureka会统计最近15分钟心跳失败的服务实例的比例是否超过了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka就会把当前实例的注册信息保护起来，不予剔除。生产环境下这很有效，保证了大多数服务依然可用。</p><p>但是这给我们的开发带来了麻烦， 因此开发阶段我们都会关闭自我保护模式：</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">server:</span>    <span class="hljs-attr">enable-self-preservation:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭自我保护模式（缺省为打开）</span>    <span class="hljs-attr">eviction-interval-timer-in-ms:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># 扫描失效服务的间隔时间（缺省为60*1000ms）</span></code></pre><h1 id="7-负载均衡Robbin"><a href="#7-负载均衡Robbin" class="headerlink" title="7.负载均衡Robbin"></a>7.负载均衡Robbin</h1><p>在刚才的案例中，我们启动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。</p><p>但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？</p><p>一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。</p><p>不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。</p><p>什么是Ribbon：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525619257397.png" srcset="/img/loading.gif" alt="1525619257397"></p><p>接下来，我们就来使用Ribbon实现负载均衡。</p><h2 id="7-1-启动两个服务实例"><a href="#7-1-启动两个服务实例" class="headerlink" title="7.1.启动两个服务实例"></a>7.1.启动两个服务实例</h2><p>首先我们启动两个user-service实例，一个8081，一个8082。</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525619515586.png" srcset="/img/loading.gif" alt="1525619515586"></p><p>Eureka监控面板：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525619546904.png" srcset="/img/loading.gif" alt="1525619546904"></p><h2 id="7-2-开启负载均衡"><a href="#7-2-开启负载均衡" class="headerlink" title="7.2.开启负载均衡"></a>7.2.开启负载均衡</h2><p>因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码：</p><p>在RestTemplate的配置方法上添加<code>@LoadBalanced</code>注解：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate(<span class="hljs-keyword">new</span> OkHttp3ClientHttpRequestFactory());&#125;</code></pre><p>修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：</p><pre><code class="hljs java"><span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DiscoveryClient discoveryClient;    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 地址直接写服务名称即可</span>        String baseUrl = <span class="hljs-string">"http://user-service/user/"</span>;        ids.forEach(id -&gt; &#123;            <span class="hljs-comment">// 我们测试多次查询，</span>            users.add(<span class="hljs-keyword">this</span>.restTemplate.getForObject(baseUrl + id, User<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;            <span class="hljs-comment">// 每次间隔500毫秒</span>            <span class="hljs-keyword">try</span> &#123;                Thread.sleep(<span class="hljs-number">500</span>);            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;);        <span class="hljs-keyword">return</span> users;    &#125;&#125;</code></pre><p>访问页面，查看结果：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525620305704.png" srcset="/img/loading.gif" alt="1525620305704"></p><p>完美！</p><h2 id="7-3-源码跟踪"><a href="#7-3-源码跟踪" class="headerlink" title="7.3.源码跟踪"></a>7.3.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code></p><p>我们进行源码跟踪：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525620483637.png" srcset="/img/loading.gif" alt="1525620483637"></p><p>继续跟入execute方法：发现获取了8082端口的服务</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525620787090.png" srcset="/img/loading.gif" alt="1525620787090"></p><p>再跟下一次，发现获取的是8081：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525620835911.png" srcset="/img/loading.gif" alt="1525620835911"></p><h2 id="7-4-负载均衡策略"><a href="#7-4-负载均衡策略" class="headerlink" title="7.4.负载均衡策略"></a>7.4.负载均衡策略</h2><p>Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下：</p><p>编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525622320277.png" srcset="/img/loading.gif" alt="1525622320277"></p><p>现在这个就是负载均衡获取实例的方法。</p><p>我们对注入这个类的对象，然后对其测试：</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">@<span class="hljs-title">SpringBootTest</span>(<span class="hljs-title">classes</span> </span>= UserConsumerDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">LoadBalanceTest</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    RibbonLoadBalancerClient client;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;            ServiceInstance instance = <span class="hljs-keyword">this</span>.client.choose(<span class="hljs-string">"user-service"</span>);            System.out.println(instance.getHost() + <span class="hljs-string">":"</span> + instance.getPort());        &#125;    &#125;&#125;</code></pre><p>结果：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525622357371.png" srcset="/img/loading.gif" alt="1525622357371"></p><p>符合了我们的预期推测，确实是轮询方式。</p><p>我们是否可以修改负载均衡的策略呢？</p><p>继续跟踪源码，发现这么一段代码：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525622652849.png" srcset="/img/loading.gif" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525622699666.png" srcset="/img/loading.gif" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525622754316.png" srcset="/img/loading.gif" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>我们注意到，这个类其实是实现了接口IRule的，查看一下：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525622817451.png" srcset="/img/loading.gif" alt="1525622817451"></p><p>定义负载均衡的规则接口。</p><p>它有以下实现：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525622876842.png" srcset="/img/loading.gif" alt="1525622876842"></p><p>SpringBoot也帮我们提供了修改负载均衡规则的配置入口：</p><pre><code class="hljs yaml"><span class="hljs-attr">user-service:</span>  <span class="hljs-attr">ribbon:</span>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RandomRule</span></code></pre><p>格式是：<code>{服务名称}.ribbon.NFLoadBalancerRuleClassName</code>，值就是IRule的实现类。</p><p>再次测试，发现结果变成了随机：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525623193949.png" srcset="/img/loading.gif" alt="1525623193949"></p><h2 id="7-5-重试机制"><a href="#7-5-重试机制" class="headerlink" title="7.5.重试机制"></a>7.5.重试机制</h2><p>Eureka的服务治理强调了CAP原则中的AP，即可用性和可靠性。它与Zookeeper这一类强调CP（一致性，可靠性）的服务治理框架最大的区别在于：Eureka为了实现更高的服务可用性，牺牲了一定的一致性，极端情况下它宁愿接收故障实例也不愿丢掉健康实例，正如我们上面所说的自我保护机制。</p><p>但是，此时如果我们调用了这些不正常的服务，调用就会失败，从而导致其它服务不能正常工作！这显然不是我们愿意看到的。</p><p>我们现在关闭一个user-service实例：</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525653565855.png" srcset="/img/loading.gif" alt="1525653565855"></p><p>因为服务剔除的延迟，consumer并不会立即得到最新的服务列表，此时再次访问你会得到错误提示：</p><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525653715488.png" srcset="/img/loading.gif" alt="1525653715488"></p><p>但是此时，8081服务其实是正常的。</p><p>因此Spring Cloud 整合了Spring Retry 来增强RestTemplate的重试能力，当一次服务调用失败后，不会立即抛出一次，而是再次重试另一个服务。</p><p>只需要简单配置即可实现Ribbon的重试：</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">cloud:</span>    <span class="hljs-attr">loadbalancer:</span>      <span class="hljs-attr">retry:</span>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启Spring Cloud的重试功能</span><span class="hljs-attr">user-service:</span>  <span class="hljs-attr">ribbon:</span>    <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># Ribbon的连接超时时间</span>    <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># Ribbon的数据读取超时时间</span>    <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作都进行重试</span>    <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 切换实例的重试次数</span>    <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 对当前实例的重试次数</span></code></pre><p>根据如上配置，当访问到某个服务超时后，它会再次尝试访问下一个服务实例，如果不行就再换一个实例，如果不行，则返回失败。切换次数取决于<code>MaxAutoRetriesNextServer</code>参数的值</p><p>引入spring-retry依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.retry<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-retry<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>我们重启user-consumer-demo，测试，发现即使user-service2宕机，也能通过另一台服务实例获取到结果！</p><p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A101/1525658269456.png" srcset="/img/loading.gif" alt="1525658269456"></p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2018/09/11/RabbitMQ/"/>
    <url>/2018/09/11/RabbitMQ/</url>
    
    <content type="html"><![CDATA[<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>###消息中间件用处：</p><ul><li><p>异步</p></li><li><p>削峰填谷</p></li><li><p>解耦</p><img src="/11/RabbitMQ/image-20200528143616174.png" srcset="/img/loading.gif" alt="image-20200528143616174"></li></ul><p><img src="/11/RabbitMQ/image-20200528143647206.png" srcset="/img/loading.gif" alt="image-20200528143647206"></p><p>###消费堆积</p><p><img src="/11/RabbitMQ/image-20200528134745010.png" srcset="/img/loading.gif" alt="image-20200528134745010"></p><p><img src="/11/RabbitMQ/image-20200528134441238.png" srcset="/img/loading.gif" alt="image-20200528134441238"></p><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><p><img src="/11/RabbitMQ/image-20200528134909904.png" srcset="/img/loading.gif" alt="image-20200528134909904"></p><p><img src="/11/RabbitMQ/image-20200528135251440.png" srcset="/img/loading.gif" alt="image-20200528135251440"></p><p><img src="/11/RabbitMQ/image-20200528135331866.png" srcset="/img/loading.gif" alt="image-20200528135331866"></p><p><img src="/11/RabbitMQ/image-20200528135430876.png" srcset="/img/loading.gif" alt="image-20200528135430876"></p><h3 id="有序消费"><a href="#有序消费" class="headerlink" title="有序消费"></a>有序消费</h3><p><img src="/11/RabbitMQ/image-20200528140144236.png" srcset="/img/loading.gif" alt="image-20200528140144236"></p><p><img src="/11/RabbitMQ/image-20200528140253420.png" srcset="/img/loading.gif" alt="image-20200528140253420"></p><p><img src="/11/RabbitMQ/image-20200528140351935.png" srcset="/img/loading.gif" alt="image-20200528140351935"></p><p>场景1解决方案</p><p><img src="/11/RabbitMQ/image-20200528140550582.png" srcset="/img/loading.gif" alt="image-20200528140550582"></p><p>场景2解决方案</p><p><img src="/11/RabbitMQ/image-20200528140721256.png" srcset="/img/loading.gif" alt="image-20200528140721256"></p><h3 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h3><p><img src="/11/RabbitMQ/image-20200528140902131.png" srcset="/img/loading.gif" alt="image-20200528140902131"></p><p><img src="/11/RabbitMQ/image-20200528153341002.png" srcset="/img/loading.gif" alt="image-20200528153341002"></p><p><img src="/11/RabbitMQ/image-20200528154105024.png" srcset="/img/loading.gif" alt="image-20200528154105024"></p><p><img src="/11/RabbitMQ/image-20200528154202709.png" srcset="/img/loading.gif" alt="image-20200528154202709"></p><p><img src="/11/RabbitMQ/image-20200528154329056.png" srcset="/img/loading.gif" alt="image-20200528154329056"></p><p><img src="/11/RabbitMQ/image-20200528154412984.png" srcset="/img/loading.gif" alt="image-20200528154412984"></p><p><img src="/11/RabbitMQ/image-20200528154457707.png" srcset="/img/loading.gif" alt="image-20200528154457707"></p><p><img src="/11/RabbitMQ/image-20200528154812285.png" srcset="/img/loading.gif" alt="image-20200528154812285"></p><p><img src="/11/RabbitMQ/image-20200528154853076.png" srcset="/img/loading.gif" alt="image-20200528154853076"></p><p><img src="/11/RabbitMQ/image-20200528154922350.png" srcset="/img/loading.gif" alt="image-20200528154922350"></p><p><img src="/11/RabbitMQ/image-20200528155514492.png" srcset="/img/loading.gif" alt="image-20200528155514492"></p><p><img src="/11/RabbitMQ/image-20200528155726993.png" srcset="/img/loading.gif" alt="image-20200528155726993"></p><p><img src="/11/RabbitMQ/image-20200528155747556.png" srcset="/img/loading.gif" alt="image-20200528155747556"></p><p><img src="/11/RabbitMQ/image-20200528155829596.png" srcset="/img/loading.gif" alt="image-20200528155829596"></p><p><img src="/11/RabbitMQ/image-20200528155907448.png" srcset="/img/loading.gif" alt="image-20200528155907448"></p><p><img src="/11/RabbitMQ/image-20200528155959525.png" srcset="/img/loading.gif" alt="image-20200528155959525"></p><p><img src="/11/RabbitMQ/image-20200528160101205.png" srcset="/img/loading.gif" alt="image-20200528160101205"></p><p><img src="/11/RabbitMQ/image-20200528160153409.png" srcset="/img/loading.gif" alt="image-20200528160153409"></p><p><img src="/11/RabbitMQ/image-20200528160240236.png" srcset="/img/loading.gif" alt="image-20200528160240236"></p><p><img src="/11/RabbitMQ/image-20200528160316389.png" srcset="/img/loading.gif" alt="image-20200528160316389"></p><p><img src="/11/RabbitMQ/image-20200528160503683.png" srcset="/img/loading.gif" alt="image-20200528160503683"></p><p><img src="/11/RabbitMQ/image-20200528160511346.png" srcset="/img/loading.gif" alt="image-20200528160511346"></p>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring</title>
    <link href="/2018/09/11/Spring/"/>
    <url>/2018/09/11/Spring/</url>
    
    <content type="html"><![CDATA[<h3 id="SpringMvc"><a href="#SpringMvc" class="headerlink" title="SpringMvc"></a>SpringMvc</h3><p>1.原理</p><blockquote><p>客户端发送请求到DispatcherServlet，DispatcherServlet根据请求的信息通过HandlerMapping找到具体的Handler，由HandlerAdapter对Handler进行具体的调用。Handler对数据处理完成以后将返回一个逻辑视图ModelAndView()对象给DispatcherServlet。DispatcherServlet通过ViewResolver将逻辑视图转化为真正的视图View做渲染返回到客户端</p></blockquote><img src="/11/Spring/image-20200715174529603.png" srcset="/img/loading.gif" alt="image-20200715174529603"><p><img src="/11/Spring/image-20200715174637194.png" srcset="/img/loading.gif" alt="image-20200715174637194"></p><p><img src="/11/Spring/image-20200715175034229.png" srcset="/img/loading.gif" alt="image-20200715175034229"></p><p><img src="/11/Spring/image-20200716153434244.png" srcset="/img/loading.gif" alt="image-20200716153434244"></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2018/09/11/%E5%8F%8D%E5%B0%84/"/>
    <url>/2018/09/11/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603110838259.png" srcset="/img/loading.gif" alt="image-20200603110838259"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603110928336.png" srcset="/img/loading.gif" alt="image-20200603110928336"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603111041132.png" srcset="/img/loading.gif" alt="image-20200603111041132"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603111249645.png" srcset="/img/loading.gif" alt="image-20200603111249645"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603111428027.png" srcset="/img/loading.gif" alt="image-20200603111428027"></p><h3 id="反射-1"><a href="#反射-1" class="headerlink" title="反射"></a>反射</h3><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603111713171.png" srcset="/img/loading.gif" alt="image-20200603111713171"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603111811588.png" srcset="/img/loading.gif" alt="image-20200603111811588"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603112111746.png" srcset="/img/loading.gif" alt="image-20200603112111746"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603112855695.png" srcset="/img/loading.gif" alt="image-20200603112855695"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603113111617.png" srcset="/img/loading.gif" alt="image-20200603113111617"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603113402518.png" srcset="/img/loading.gif" alt="image-20200603113402518"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603113327944.png" srcset="/img/loading.gif" alt="image-20200603113327944"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603113921815.png" srcset="/img/loading.gif" alt="image-20200603113921815"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603113956401.png" srcset="/img/loading.gif" alt="image-20200603113956401"></p><p><img src="/11/%E5%8F%8D%E5%B0%84/image-20200603115040070.png" srcset="/img/loading.gif" alt="image-20200603115040070"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/2018/09/10/Redis/"/>
    <url>/2018/09/10/Redis/</url>
    
    <content type="html"><![CDATA[<h2 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h2><p>CAP原则又称CAP定理，指的是在一个<a href="https://baike.baidu.com/item/分布式系统/4905336" target="_blank" rel="noopener">分布式系统</a>中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p><p>redis  AP</p><h3 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h3><p><img src="/10/Redis/image-20200604184727075.png" srcset="/img/loading.gif" alt="image-20200604184727075"></p><p><img src="/10/Redis/image-20200604185033157.png" srcset="/img/loading.gif" alt="image-20200604185033157"></p><p><img src="/10/Redis/image-20200604190008572.png" srcset="/img/loading.gif" alt="image-20200604190008572"></p><h4 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h4><p><img src="/10/Redis/image-20200604172328294.png" srcset="/img/loading.gif" alt="image-20200604172328294"></p><p><img src="/10/Redis/image-20200604173457902.png" srcset="/img/loading.gif" alt="image-20200604173457902"></p><p><img src="/10/Redis/image-20200604174259502.png" srcset="/img/loading.gif" alt="image-20200604174259502"></p><p><img src="/10/Redis/image-20200603162847616.png" srcset="/img/loading.gif" alt="image-20200603162847616"></p><p><img src="/10/Redis/image-20200603163010256.png" srcset="/img/loading.gif" alt="image-20200603163010256"></p><p>1.缓存雪崩</p><p><img src="/10/Redis/image-20200522093751823.png" srcset="/img/loading.gif" alt="image-20200522093751823"></p><p><img src="/10/Redis/image-20200522094652297.png" srcset="/img/loading.gif" alt="image-20200522094652297"></p><p><img src="/10/Redis/image-20200522094849554.png" srcset="/img/loading.gif" alt="image-20200522094849554"></p><p>2.缓存击穿</p><p><img src="/10/Redis/image-20200522095118449.png" srcset="/img/loading.gif" alt="image-20200522095118449"></p><p><img src="/10/Redis/image-20200522095242672.png" srcset="/img/loading.gif" alt="image-20200522095242672"></p><p>3.缓存穿透</p><p><img src="/10/Redis/image-20200522100036514.png" srcset="/img/loading.gif" alt="image-20200522100036514"></p><p><img src="/10/Redis/image-20200522100134282.png" srcset="/img/loading.gif" alt="image-20200522100134282"></p><p>分布式锁（redisson中间件）</p><p><img src="/10/Redis/image-20200522104027844.png" srcset="/img/loading.gif" alt="image-20200522104027844"></p><p><img src="/10/Redis/image-20200522104214277.png" srcset="/img/loading.gif" alt="image-20200522104214277"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
