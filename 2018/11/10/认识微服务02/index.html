

<!DOCTYPE html>
<html lang="en" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="wdx">
  <meta name="keywords" content="">
  <title>认识微服务02 - Tuan Dog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>TUAN DOG</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2018-11-10 11:00" pubdate>
      November 10, 2018 am
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      63
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">认识微服务02</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul>
<li>会配置Hystix熔断</li>
<li>会使用Feign进行远程调用</li>
<li>能独立搭建Zuul网关</li>
<li>能编写Zuul的拦截器</li>
</ul>
<h1 id="1-Hystix"><a href="#1-Hystix" class="headerlink" title="1.Hystix"></a>1.Hystix</h1><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h2><p>Hystix，即熔断器。</p>
<p>主页：<a href="https://github.com/Netflix/Hystrix/" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/</a></p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658740266.png" srcset="/img/loading.gif" alt="1525658740266"></p>
<p>Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658562507.png" srcset="/img/loading.gif" alt="1525658562507"></p>
<h2 id="1-2-熔断器的工作机制："><a href="#1-2-熔断器的工作机制：" class="headerlink" title="1.2.熔断器的工作机制："></a>1.2.熔断器的工作机制：</h2><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658640314.png" srcset="/img/loading.gif" alt="1525658640314"></p>
<p>正常工作的情况下，客户端请求调用服务API接口：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658906255.png" srcset="/img/loading.gif" alt="1525658906255"></p>
<p>当有服务出现异常时，直接进行失败回滚，服务降级处理：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525658983518.png" srcset="/img/loading.gif" alt="1525658983518"></p>
<p>当服务繁忙时，如果服务出现异常，不是粗暴的直接报错，而是返回一个友好的提示，虽然拒绝了用户的访问，但是会返回一个结果。</p>
<p>这就好比去买鱼，平常超市买鱼会额外赠送杀鱼的服务。等到逢年过节，超时繁忙时，可能就不提供杀鱼服务了，这就是服务的降级。</p>
<p>系统特别繁忙时，一些次要服务暂时中断，优先保证主要服务的畅通，一切资源优先让给主要服务来使用，在双十一、618时，京东天猫都会采用这样的策略。</p>
<h2 id="1-3-动手实践"><a href="#1-3-动手实践" class="headerlink" title="1.3.动手实践"></a>1.3.动手实践</h2><h3 id="1-3-1-引入依赖"><a href="#1-3-1-引入依赖" class="headerlink" title="1.3.1.引入依赖"></a>1.3.1.引入依赖</h3><p>首先在user-consumer中引入Hystix依赖：</p>
<pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<h3 id="1-3-2-开启熔断"><a href="#1-3-2-开启熔断" class="headerlink" title="1.3.2.开启熔断"></a>1.3.2.开启熔断</h3><h3 id="1-3-2-改造消费者"><a href="#1-3-2-改造消费者" class="headerlink" title="1.3.2.改造消费者"></a>1.3.2.改造消费者</h3><p>我们改造user-consumer，添加一个用来访问的user服务的DAO，并且声明一个失败时的回滚处理函数：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> RestTemplate restTemplate;

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(UserDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;

    <span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"queryUserByIdFallback"</span>)
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Long id)</span></span>&#123;
        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();
        String url = <span class="hljs-string">"http://user-service/user/"</span> + id;
        User user = <span class="hljs-keyword">this</span>.restTemplate.getForObject(url, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;
        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();
        <span class="hljs-comment">// 记录访问用时：</span>
        logger.info(<span class="hljs-string">"访问用时：&#123;&#125;"</span>, end - begin);
        <span class="hljs-keyword">return</span> user;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserByIdFallback</span><span class="hljs-params">(Long id)</span></span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setId(id);
        user.setName(<span class="hljs-string">"用户信息查询出现异常！"</span>);
        <span class="hljs-keyword">return</span> user;
    &#125;
&#125;</code></pre>

<ul>
<li><code>@HystrixCommand(fallbackMethod=&quot;queryUserByIdFallback&quot;)</code>：声明一个失败回滚处理函数queryUserByIdFallback，当queryUserById执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</li>
<li>为了方便查看熔断的触发时机，我们记录请求访问时间。</li>
</ul>
<p>在原来的业务逻辑中调用这个DAO：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserDao userDao;

    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;
        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        ids.forEach(id -&gt; &#123;
            <span class="hljs-comment">// 我们测试多次查询，</span>
            users.add(<span class="hljs-keyword">this</span>.userDao.queryUserById(id));
        &#125;);
        <span class="hljs-keyword">return</span> users;
    &#125;
&#125;</code></pre>

<h3 id="1-3-3-改造服务提供者"><a href="#1-3-3-改造服务提供者" class="headerlink" title="1.3.3.改造服务提供者"></a>1.3.3.改造服务提供者</h3><p>改造服务提供者，随机休眠一段时间，以触发熔断：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserMapper userMapper;

    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryById</span><span class="hljs-params">(Long id)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;
        <span class="hljs-comment">// 为了演示超时现象，我们在这里然线程休眠,时间随机 0~2000毫秒</span>
        Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">2000</span>));
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.userMapper.selectByPrimaryKey(id);
    &#125;
&#125;</code></pre>

<h3 id="1-3-4-启动测试"><a href="#1-3-4-启动测试" class="headerlink" title="1.3.4.启动测试"></a>1.3.4.启动测试</h3><p>然后运行并查看日志：</p>
<p>id为9、10、11的访问时间分别是：</p>
<p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525661641660.png" srcset="/img/loading.gif" alt="1525661641660"></p>
<p>id为12的访问时间：</p>
<p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525661669136.png" srcset="/img/loading.gif" alt="1525661669136"></p>
<p>因此，只有12是正常访问，其它都会触发熔断，我们来查看结果：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525661720656.png" srcset="/img/loading.gif" alt="1525661720656"></p>
<h3 id="1-3-5-优化"><a href="#1-3-5-优化" class="headerlink" title="1.3.5.优化"></a>1.3.5.优化</h3><p>虽然熔断实现了，但是我们的重试机制似乎没有生效，是这样吗？</p>
<p>其实这里是因为我们的Ribbon超时时间设置的是1000ms:</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525666632542.png" srcset="/img/loading.gif" alt="1525666632542"></p>
<p>而Hystix的超时时间默认也是1000ms，因此重试机制没有被触发，而是先触发了熔断。</p>
<p>所以，Ribbon的超时时间一定要小于Hystix的超时时间。</p>
<p>我们可以通过<code>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds</code>来设置Hystrix超时时间。</p>
<pre><code class="hljs yaml"><span class="hljs-attr">hystrix:</span>
  <span class="hljs-attr">command:</span>
  	<span class="hljs-attr">default:</span>
        <span class="hljs-attr">execution:</span>
          <span class="hljs-attr">isolation:</span>
            <span class="hljs-attr">thread:</span>
              <span class="hljs-attr">timeoutInMillisecond:</span> <span class="hljs-number">6000</span> <span class="hljs-comment"># 设置hystrix的超时时间为6000ms</span></code></pre>



<h1 id="2-Feign"><a href="#2-Feign" class="headerlink" title="2.Feign"></a>2.Feign</h1><p>在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：</p>
<pre><code class="hljs java">String baseUrl = <span class="hljs-string">"http://user-service/user/"</span>;
User user = <span class="hljs-keyword">this</span>.restTemplate.getForObject(baseUrl + id, User<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span></code></pre>

<p>如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？</p>
<p>这就是我们接下来要学的Feign的功能了。</p>
<h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1.简介"></a>2.1.简介</h2><p>有道词典的英文解释：</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525662976679.png" srcset="/img/loading.gif" alt="1525662976679"></p>
<p>为什么叫伪装？</p>
<p>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。</p>
<p>项目主页：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525652009416.png" srcset="/img/loading.gif" alt="1525652009416"></p>
<h2 id="2-2-快速入门"><a href="#2-2-快速入门" class="headerlink" title="2.2.快速入门"></a>2.2.快速入门</h2><h3 id="2-2-1-导入依赖"><a href="#2-2-1-导入依赖" class="headerlink" title="2.2.1.导入依赖"></a>2.2.1.导入依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>

<h3 id="2-2-2-Feign的客户端"><a href="#2-2-2-Feign的客户端" class="headerlink" title="2.2.2.Feign的客户端"></a>2.2.2.Feign的客户端</h3><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(<span class="hljs-string">"user-service"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;"</span>)
    <span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
&#125;</code></pre>

<ul>
<li>首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像</li>
<li><code>@FeignClient</code>，声明这是一个Feign客户端，类似<code>@Mapper</code>注解。同时通过<code>value</code>属性指定服务名称</li>
<li>接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果</li>
</ul>
<p>改造原来的调用逻辑，不再调用UserDao：</p>
<pre><code class="hljs java"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;

    <span class="hljs-meta">@Autowired</span>
    <span class="hljs-keyword">private</span> UserFeignClient userFeignClient;

    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">queryUserByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> </span>&#123;
        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
        ids.forEach(id -&gt; &#123;
            <span class="hljs-comment">// 我们测试多次查询，</span>
            users.add(<span class="hljs-keyword">this</span>.userFeignClient.queryUserById(id));
        &#125;);
        <span class="hljs-keyword">return</span> users;
    &#125;
&#125;</code></pre>

<h3 id="2-2-3-开启Feign功能"><a href="#2-2-3-开启Feign功能" class="headerlink" title="2.2.3.开启Feign功能"></a>2.2.3.开启Feign功能</h3><p>我们在启动类上，添加注解，开启Feign功能</p>
<pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-meta">@EnableHystrix</span>
<span class="hljs-meta">@EnableFeignClients</span> <span class="hljs-comment">// 开启Feign功能</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserConsumerDemoApplication</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        SpringApplication.run(UserConsumerDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
    &#125;
&#125;</code></pre>

<ul>
<li>你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了</li>
</ul>
<h3 id="2-2-4-启动测试："><a href="#2-2-4-启动测试：" class="headerlink" title="2.2.4.启动测试："></a>2.2.4.启动测试：</h3><p>访问接口：</p>
<p> <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525666476326.png" srcset="/img/loading.gif" alt="1525666476326"></p>
<p>正常获取到了结果。</p>
<h2 id="2-3-负载均衡"><a href="#2-3-负载均衡" class="headerlink" title="2.3.负载均衡"></a>2.3.负载均衡</h2><p>Feign中本身已经集成了Ribbon依赖和自动配置：</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525672070679.png" srcset="/img/loading.gif" alt="1525672070679"></p>
<p>因此我们不需要额外引入依赖，也不需要再注册<code>RestTemplate</code>对象。</p>
<p>另外，我们可以像上节课中讲的那样去配置Ribbon，可以通过<code>ribbon.xx</code>来进行全局配置。也可以通过<code>服务名.ribbon.xx</code>来对指定服务配置：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">user-service:</span>
  <span class="hljs-attr">ribbon:</span>
    <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># 连接超时时间(ms)</span>
    <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">1000</span> <span class="hljs-comment"># 通信超时时间(ms)</span>
    <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作重试</span>
    <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一服务不同实例的重试次数</span>
    <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一实例的重试次数</span></code></pre>

<h2 id="2-4-Hystix支持"><a href="#2-4-Hystix支持" class="headerlink" title="2.4.Hystix支持"></a>2.4.Hystix支持</h2><p>Feign默认也有对Hystix的集成：</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525672466192.png" srcset="/img/loading.gif" alt="1525672466192"></p>
<p>只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>
  <span class="hljs-attr">hystrix:</span>
    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启Feign的熔断功能</span></code></pre>

<p>但是，Feign中的Fallback配置不像Ribbon中那样简单了。</p>
<p>1）首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类</p>
<pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFeignClientFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUserById</span><span class="hljs-params">(Long id)</span> </span>&#123;
        User user = <span class="hljs-keyword">new</span> User();
        user.setId(id);
        user.setName(<span class="hljs-string">"用户查询出现异常！"</span>);
        <span class="hljs-keyword">return</span> user;
    &#125;
&#125;</code></pre>

<p>2）然后在UserFeignClient中，指定刚才编写的实现类</p>
<pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"user-service"</span>, fallback = UserFeignClientFallback<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;

    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;"</span>)
    <span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
&#125;</code></pre>

<p>3）重启测试：</p>
<p>我们关闭user-service服务，然后在页面访问：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525673049875.png" srcset="/img/loading.gif" alt="1525673049875"></p>
<h2 id="2-5-请求压缩-了解"><a href="#2-5-请求压缩-了解" class="headerlink" title="2.5.请求压缩(了解)"></a>2.5.请求压缩(了解)</h2><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>
  <span class="hljs-attr">compression:</span>
    <span class="hljs-attr">request:</span>
      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启请求压缩</span>
    <span class="hljs-attr">response:</span>
      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启响应压缩</span></code></pre>

<p>同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">feign:</span>
  <span class="hljs-attr">compression:</span>
    <span class="hljs-attr">request:</span>
      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启请求压缩</span>
      <span class="hljs-attr">mime-types:</span> <span class="hljs-string">text/html,application/xml,application/json</span> <span class="hljs-comment"># 设置压缩的数据类型</span>
      <span class="hljs-attr">min-request-size:</span> <span class="hljs-number">2048</span> <span class="hljs-comment"># 设置触发压缩的大小下限</span></code></pre>

<p>注：上面的数据类型、压缩大小下限均为默认值。</p>
<h2 id="2-6-日志级别-了解"><a href="#2-6-日志级别-了解" class="headerlink" title="2.6.日志级别(了解)"></a>2.6.日志级别(了解)</h2><p>前面讲过，通过<code>logging.level.xx=debug</code>来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p>
<p>1）设置com.leyou包下的日志级别都为debug</p>
<pre><code class="hljs yaml"><span class="hljs-attr">logging:</span>
  <span class="hljs-attr">level:</span>
    <span class="hljs-attr">com.leyou:</span> <span class="hljs-string">debug</span></code></pre>

<p>2）编写配置类，定义日志级别</p>
<pre><code class="hljs java"><span class="hljs-meta">@Configuration</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;
    <span class="hljs-meta">@Bean</span>
    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-keyword">return</span> Logger.Level.FULL;
    &#125;
&#125;</code></pre>

<p>这里指定的Level级别是FULL，Feign支持4种级别：</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525674373507.png" srcset="/img/loading.gif" alt="1525674373507"></p>
<ul>
<li>NONE：不记录任何日志信息，这是默认值。</li>
<li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
<p>3）在FeignClient中指定配置类：</p>
<pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"user-service"</span>, fallback = UserFeignClientFallback<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">configuration</span> </span>= FeignConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>
<span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">UserFeignClient</span> </span>&#123;
    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/user/&#123;id&#125;"</span>)
    <span class="hljs-function">User <span class="hljs-title">queryUserById</span><span class="hljs-params">(@PathVariable(<span class="hljs-string">"id"</span>)</span> Long id)</span>;
&#125;</code></pre>

<p>4）重启项目，即可看到每次访问的日志：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525674544569.png" srcset="/img/loading.gif" alt="1525674544569"></p>
<h1 id="3-Zuul网关"><a href="#3-Zuul网关" class="headerlink" title="3.Zuul网关"></a>3.Zuul网关</h1><p>通过前面的学习，使用Spring Cloud实现微服务的架构基本成型，大致是这样的：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525674644660.png" srcset="/img/loading.gif" alt="1525674644660"></p>
<p>我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。</p>
<p>在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。我们把焦点聚集在对外服务这块，直接暴露我们的服务地址，这样的实现是否合理，或者是否有更好的实现方式呢？</p>
<p>先来说说这样架构需要做的一些事儿以及存在的不足：</p>
<ul>
<li>首先，破坏了服务无状态特点。<ul>
<li>为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。</li>
<li>从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外考虑对接口访问的控制处理。</li>
</ul>
</li>
<li>其次，无法直接复用既有接口。<ul>
<li>当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。</li>
</ul>
</li>
</ul>
<p>面对类似上面的问题，我们要如何解决呢？答案是：服务网关！</p>
<p>为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器的 服务网关。</p>
<p>服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了<code>权限控制</code>等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。</p>
<h2 id="3-1-简介"><a href="#3-1-简介" class="headerlink" title="3.1.简介"></a>3.1.简介</h2><p>官网：<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">https://github.com/Netflix/zuul</a></p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675037152.png" srcset="/img/loading.gif" alt="1525675037152"></p>
<p>Zuul：维基百科：</p>
<p>电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。</p>
<p>事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675168152.png" srcset="/img/loading.gif" alt="1525675168152"></p>
<h2 id="3-2-Zuul加入后的架构"><a href="#3-2-Zuul加入后的架构" class="headerlink" title="3.2.Zuul加入后的架构"></a>3.2.Zuul加入后的架构</h2><p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675648881.png" srcset="/img/loading.gif" alt="1525675648881"></p>
<ul>
<li>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</li>
</ul>
<h2 id="3-3-快速入门"><a href="#3-3-快速入门" class="headerlink" title="3.3.快速入门"></a>3.3.快速入门</h2><h3 id="3-3-1-新建工程"><a href="#3-3-1-新建工程" class="headerlink" title="3.3.1.新建工程"></a>3.3.1.新建工程</h3><p>填写基本信息：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675928548.png" srcset="/img/loading.gif" alt="1525675928548"></p>
<p>添加Zuul依赖：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525675991833.png" srcset="/img/loading.gif" alt="1525675991833"></p>
<h3 id="3-3-2-编写启动类"><a href="#3-3-2-编写启动类" class="headerlink" title="3.3.2.编写启动类"></a>3.3.2.编写启动类</h3><p>通过<code>@EnableZuulProxy</code>注解开启Zuul的功能：</p>
<pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableZuulProxy</span> <span class="hljs-comment">// 开启Zuul的网关功能</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZuulDemoApplication</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		SpringApplication.run(ZuulDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
	&#125;
&#125;</code></pre>

<h3 id="3-3-3-编写配置"><a href="#3-3-3-编写配置" class="headerlink" title="3.3.3.编写配置"></a>3.3.3.编写配置</h3><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>
  <span class="hljs-attr">port:</span> <span class="hljs-number">10010</span> <span class="hljs-comment">#服务端口</span>
<span class="hljs-attr">spring:</span> 
  <span class="hljs-attr">application:</span>  
    <span class="hljs-attr">name:</span> <span class="hljs-string">api-gateway</span> <span class="hljs-comment">#指定服务名</span></code></pre>

<h3 id="3-3-4-编写路由规则"><a href="#3-3-4-编写路由规则" class="headerlink" title="3.3.4.编写路由规则"></a>3.3.4.编写路由规则</h3><p>我们需要用Zuul来代理user-service服务，先看一下控制面板中的服务状态：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525676797879.png" srcset="/img/loading.gif" alt="1525676797879"></p>
<ul>
<li>ip为：127.0.0.1</li>
<li>端口为：8081</li>
</ul>
<p>映射规则：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>
  <span class="hljs-attr">routes:</span>
    <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span>
      <span class="hljs-attr">path:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span>
      <span class="hljs-attr">url:</span> <span class="hljs-string">http://127.0.0.1:8081</span> <span class="hljs-comment"># 映射路径对应的实际url地址</span></code></pre>

<p>我们将符合<code>path</code> 规则的一切请求，都代理到 <code>url</code>参数指定的地址</p>
<p>本例中，我们将 <code>/user-service/**</code>开头的请求，代理到<a href="http://127.0.0.1:8081" target="_blank" rel="noopener">http://127.0.0.1:8081</a></p>
<h3 id="3-3-5-启动测试："><a href="#3-3-5-启动测试：" class="headerlink" title="3.3.5.启动测试："></a>3.3.5.启动测试：</h3><p>访问的路径中需要加上配置规则的映射路径，我们访问：<a href="http://127.0.0.1:8081/user-service/user/10" target="_blank" rel="noopener">http://127.0.0.1:8081/user-service/user/10</a></p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525677046705.png" srcset="/img/loading.gif" alt="1525677046705"></p>
<h2 id="3-4-面向服务的路由"><a href="#3-4-面向服务的路由" class="headerlink" title="3.4.面向服务的路由"></a>3.4.面向服务的路由</h2><p>在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。</p>
<p>我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！</p>
<h3 id="3-4-1-添加Eureka客户端依赖"><a href="#3-4-1-添加Eureka客户端依赖" class="headerlink" title="3.4.1.添加Eureka客户端依赖"></a>3.4.1.添加Eureka客户端依赖</h3><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre>



<h3 id="3-4-2-开启Eureka客户端发现功能"><a href="#3-4-2-开启Eureka客户端发现功能" class="headerlink" title="3.4.2.开启Eureka客户端发现功能"></a>3.4.2.开启Eureka客户端发现功能</h3><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span>
<span class="hljs-meta">@EnableZuulProxy</span> <span class="hljs-comment">// 开启Zuul的网关功能</span>
<span class="hljs-meta">@EnableDiscoveryClient</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZuulDemoApplication</span> </span>&#123;

	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
		SpringApplication.run(ZuulDemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;
	&#125;
&#125;</code></pre>

<h3 id="3-4-3-添加Eureka配置，获取服务信息"><a href="#3-4-3-添加Eureka配置，获取服务信息" class="headerlink" title="3.4.3.添加Eureka配置，获取服务信息"></a>3.4.3.添加Eureka配置，获取服务信息</h3><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>
  <span class="hljs-attr">client:</span>
    <span class="hljs-attr">registry-fetch-interval-seconds:</span> <span class="hljs-number">5</span> <span class="hljs-comment"># 获取服务列表的周期：5s</span>
    <span class="hljs-attr">service-url:</span>
      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:10086/eureka</span>
  <span class="hljs-attr">instance:</span>
    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>
    <span class="hljs-attr">ip-address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span></code></pre>

<h3 id="3-4-4-修改映射配置，通过服务名称获取"><a href="#3-4-4-修改映射配置，通过服务名称获取" class="headerlink" title="3.4.4.修改映射配置，通过服务名称获取"></a>3.4.4.修改映射配置，通过服务名称获取</h3><p>因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p>
<pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>
  <span class="hljs-attr">routes:</span>
    <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span>
      <span class="hljs-attr">path:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span>
      <span class="hljs-attr">serviceId:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 指定服务名称</span></code></pre>



<h3 id="3-4-5-启动测试"><a href="#3-4-5-启动测试" class="headerlink" title="3.4.5.启动测试"></a>3.4.5.启动测试</h3><p>再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525677821212.png" srcset="/img/loading.gif" alt="1525677821212"></p>
<p>日志中可以看到使用了负载均衡器：</p>
<p><img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525677891119.png" srcset="/img/loading.gif" alt="1525677891119"></p>
<h2 id="3-5-简化的路由配置"><a href="#3-5-简化的路由配置" class="headerlink" title="3.5.简化的路由配置"></a>3.5.简化的路由配置</h2><p>在刚才的配置中，我们的规则是这样的：</p>
<ul>
<li><code>zuul.routes.&lt;route&gt;.path=/xxx/**</code>： 来指定映射路径。<code>&lt;route&gt;</code>是自定义的路由名</li>
<li><code>zuul.routes.&lt;route&gt;.serviceId=/user-service</code>：来指定服务名。</li>
</ul>
<p>而大多数情况下，我们的<code>&lt;route&gt;</code>路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></p>
<p>比方说上面我们关于user-service的配置可以简化为一条：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>
  <span class="hljs-attr">routes:</span>
    <span class="hljs-attr">user-service:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span></code></pre>

<p>省去了对服务名称的配置。</p>
<h2 id="3-6-默认的路由规则"><a href="#3-6-默认的路由规则" class="headerlink" title="3.6.默认的路由规则"></a>3.6.默认的路由规则</h2><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：</p>
<ul>
<li>默认情况下，一切服务的映射路径就是服务名本身。<ul>
<li>例如服务名为：<code>user-service</code>，则默认的映射路径就是：<code>/user-service/**</code></li>
</ul>
</li>
</ul>
<p>也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。</p>
<h2 id="3-7-路由前缀"><a href="#3-7-路由前缀" class="headerlink" title="3.7.路由前缀"></a>3.7.路由前缀</h2><p>配置示例：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>
  <span class="hljs-attr">prefix:</span> <span class="hljs-string">/api</span> <span class="hljs-comment"># 添加路由前缀</span>
  <span class="hljs-attr">routes:</span>
      <span class="hljs-attr">user-service:</span> <span class="hljs-comment"># 这里是路由id，随意写</span>
        <span class="hljs-attr">path:</span> <span class="hljs-string">/user-service/**</span> <span class="hljs-comment"># 这里是映射路径</span>
        <span class="hljs-attr">service-id:</span> <span class="hljs-string">user-service</span> <span class="hljs-comment"># 指定服务名称</span></code></pre>

<p>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。</p>
<p>路径<code>/api/user-service/user/1</code>将会被代理到<code>/user-service/user/1</code></p>
<h2 id="3-8-过滤器"><a href="#3-8-过滤器" class="headerlink" title="3.8.过滤器"></a>3.8.过滤器</h2><p>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。</p>
<h3 id="3-8-1-ZuulFilter"><a href="#3-8-1-ZuulFilter" class="headerlink" title="3.8.1.ZuulFilter"></a>3.8.1.ZuulFilter</h3><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p>
<pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> ZuulFilter implements IZuulFilter&#123;

    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span></span>;
    
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// 来自IZuulFilter</span>

    <span class="hljs-function">Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException</span>;<span class="hljs-comment">// IZuulFilter</span>
&#125;</code></pre>

<ul>
<li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li>
<li><code>run</code>：过滤器的具体业务逻辑。</li>
<li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul>
<li><code>pre</code>：请求在被路由之前执行</li>
<li><code>routing</code>：在路由请求时调用</li>
<li><code>post</code>：在routing和errror过滤器之后调用</li>
<li><code>error</code>：处理请求时发生错误调用</li>
</ul>
</li>
<li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li>
</ul>
<h3 id="3-8-2-过滤器执行生命周期："><a href="#3-8-2-过滤器执行生命周期：" class="headerlink" title="3.8.2.过滤器执行生命周期："></a>3.8.2.过滤器执行生命周期：</h3><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525681866862.png" srcset="/img/loading.gif" alt="1525681866862"></p>
<ul>
<li>正常流程：<ul>
<li>请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</li>
</ul>
</li>
<li>异常流程：<ul>
<li>整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</li>
<li>如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。</li>
<li>如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。</li>
</ul>
</li>
</ul>
<p>所有内置过滤器列表：</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525682427811.png" srcset="/img/loading.gif" alt="1525682427811"></p>
<h3 id="3-8-3-使用场景"><a href="#3-8-3-使用场景" class="headerlink" title="3.8.3.使用场景"></a>3.8.3.使用场景</h3><p>场景非常多：</p>
<ul>
<li>请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了</li>
<li>异常处理：一般会在error类型和post类型过滤器中结合来处理。</li>
<li>服务调用时长统计：pre和post结合使用。</li>
</ul>
<h2 id="3-9-自定义过滤器"><a href="#3-9-自定义过滤器" class="headerlink" title="3.9.自定义过滤器"></a>3.9.自定义过滤器</h2><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p>
<h3 id="3-9-1-定义过滤器类"><a href="#3-9-1-定义过滤器类" class="headerlink" title="3.9.1.定义过滤器类"></a>3.9.1.定义过滤器类</h3><pre><code class="hljs java"><span class="hljs-meta">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">filterType</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 登录校验，肯定是在前置拦截</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"pre"</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">filterOrder</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 顺序设置为1</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldFilter</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-comment">// 返回true，代表过滤器生效。</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ZuulException </span>&#123;
        <span class="hljs-comment">// 登录校验逻辑。</span>
        <span class="hljs-comment">// 1）获取Zuul提供的请求上下文对象</span>
        RequestContext ctx = RequestContext.getCurrentContext();
        <span class="hljs-comment">// 2) 从上下文中获取request对象</span>
        HttpServletRequest req = ctx.getRequest();
        <span class="hljs-comment">// 3) 从请求中获取token</span>
        String token = req.getParameter(<span class="hljs-string">"access-token"</span>);
        <span class="hljs-comment">// 4) 判断</span>
        <span class="hljs-keyword">if</span>(token == <span class="hljs-keyword">null</span> || <span class="hljs-string">""</span>.equals(token.trim()))&#123;
            <span class="hljs-comment">// 没有token，登录校验失败，拦截</span>
            ctx.setSendZuulResponse(<span class="hljs-keyword">false</span>);
            <span class="hljs-comment">// 返回401状态码。也可以考虑重定向到登录页。</span>
            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());
        &#125;
        <span class="hljs-comment">// 校验通过，可以考虑把用户信息放入上下文，继续向后执行</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    &#125;
&#125;</code></pre>



<h3 id="3-9-2-测试"><a href="#3-9-2-测试" class="headerlink" title="3.9.2.测试"></a>3.9.2.测试</h3><p>没有token参数时，访问失败：</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525683285697.png" srcset="/img/loading.gif" alt="1525683285697"></p>
<p>添加token参数后：</p>
<p>​    <img src="/10/%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A102/1525683354113.png" srcset="/img/loading.gif" alt="1525683354113"></p>
<h2 id="3-10-负载均衡和熔断"><a href="#3-10-负载均衡和熔断" class="headerlink" title="3.10.负载均衡和熔断"></a>3.10.负载均衡和熔断</h2><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">zuul:</span>
  <span class="hljs-attr">retryable:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">ribbon:</span>
  <span class="hljs-attr">ConnectTimeout:</span> <span class="hljs-number">250</span> <span class="hljs-comment"># 连接超时时间(ms)</span>
  <span class="hljs-attr">ReadTimeout:</span> <span class="hljs-number">2000</span> <span class="hljs-comment"># 通信超时时间(ms)</span>
  <span class="hljs-attr">OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 是否对所有操作重试</span>
  <span class="hljs-attr">MaxAutoRetriesNextServer:</span> <span class="hljs-number">2</span> <span class="hljs-comment"># 同一服务不同实例的重试次数</span>
  <span class="hljs-attr">MaxAutoRetries:</span> <span class="hljs-number">1</span> <span class="hljs-comment"># 同一实例的重试次数</span>
<span class="hljs-attr">hystrix:</span>
  <span class="hljs-attr">command:</span>
  	<span class="hljs-attr">default:</span>
        <span class="hljs-attr">execution:</span>
          <span class="hljs-attr">isolation:</span>
            <span class="hljs-attr">thread:</span>
              <span class="hljs-attr">timeoutInMillisecond:</span> <span class="hljs-number">6000</span> <span class="hljs-comment"># 熔断超时时长：6000ms</span></code></pre>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/SpringCloud/">SpringCloud</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2018/11/11/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">IDEA快捷键</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2018/11/10/SQL%E8%B0%83%E4%BC%98/">
                        <span class="hidden-mobile">SQL调优</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <script type="text/javascript">
    function loadUtterances() {
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'wdx13666/comment');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('theme', 'github-light');
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    }
    waitElementVisible('comments', loadUtterances)
  </script>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-md">
    <div class="container custom post-content mx-auto">
      <img src="https://octodex.github.com/images/jetpacktocat.png" srcset="/img/loading.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;">
    </div>
  </div>


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  
    <!-- APlayer 音乐播放器 -->
    <div id="aplayer"></div>
    <script defer src="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.js" ></script>
<link  rel="stylesheet" href="https://cdn.staticfile.org/aplayer/1.10.1/APlayer.min.css" />
<script type="text/javascript">
  var oldLoadAp = window.onload;
  window.onload = function () {
    oldLoadAp && oldLoadAp();

    new APlayer({
      container: document.getElementById('aplayer'),
      fixed: true,
      autoplay: 'false' === 'true',
      loop: 'all',
      order: 'random',
      theme: '#b7daff',
      preload: 'none',
      audio: [{"name":"name","artist":"artist","url":"/songs/test.mp3","cover":"/img/cover.jpg"},{"name":"name","artist":"artist","url":"https://...url.mp3","cover":"https://...cover.jpg"}]
    });
  }
</script>

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP备20023356号-1</a>
    
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h5',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 6,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "认识微服务02&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>







  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  














</body>
</html>
